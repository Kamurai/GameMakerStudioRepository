<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-100</depth>
  <persistent>0</persistent>
  <parentName>self</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Emitting = false;
Searching = false;

EmitTracker = 0;
EmitCount = 0;
//EmitArrayX[0] = 0; //obj_Emitter.x;
//EmitArrayY[0] = 0; //obj_Emitter.y;

//EmitAngle = 90; //obj_Emitter.image_angle
ReflectiveAngle = 0;

//i = 0; //obj_Emitter.x;
//j = 0; //obj_Emitter.y;

AdjustX = 0;
AdjustY = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(Emitting)
{
    //draw beam path based on returned array:
    //walk through emit array based on emit count
    for(tracker = 0; tracker &lt; (EmitCount); tracker++)
    {
        //draw beam sprite from EmitArrayX[tracker],EmitArrayY[tracker] to EmitArrayX[tracker+1],Emit[tracker+1]
//        draw_sprite_stretched(spr_Beam_Standard, 0, EmitArrayX[tracker], EmitArrayY[tracker],EmitArrayX[tracker+1],EmitArrayY[tracker+1]);
//        draw_sprite_stretched(spr_Beam_Standard, 0, EmitArrayX[tracker+1], EmitArrayY[tracker+1],32,EmitArrayY[tracker+1]-EmitArrayY[tracker]);
//        draw_sprite_stretched(spr_Beam_Standard, 0, EmitArrayX[1], EmitArrayY[1],4,EmitArrayY[0]-EmitArrayY[1]);
        draw_line(EmitArrayX[tracker], EmitArrayY[tracker],EmitArrayX[tracker+1],EmitArrayY[tracker+1]);
    }    
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(Emitting == true)
{
    Emitting = false;
}
else
{

    //determine beam path:
    EmitArrayX[0] = obj_Emitter.x;
    EmitArrayY[0] = obj_Emitter.y;
    
    EmitTracker = 1;
    EmitCount = 0;
    
    i = obj_Emitter.x;
    j = obj_Emitter.y;
    
    while(!Emitting)
    {
        
        //determine angle/emit direction
        if(EmitAngle == 0)
        {
            AdjustX = 1;
            AdjustY = 0;
        }
        else if(EmitAngle == 90)
        {
            AdjustX = 0;
            AdjustY = -1;
        }
        else if(EmitAngle == 180)
        {
            AdjustX = -1;
            AdjustY = 0;
        }
        else if(EmitAngle == 270)
        {
            AdjustX = 0;
            AdjustY = 1;    
        }
        else if(EmitAngle == 360)
        {
            AdjustX = 1;
            AdjustY = 0;    
        }
        else if((EmitAngle &gt; 0) &amp;&amp; (EmitAngle &lt; 90))
        {
            AdjustX = cos(EmitAngle);
            AdjustY = sin(EmitAngle) * (-1);
        }
        else if((EmitAngle &gt; 90) &amp;&amp; (EmitAngle &lt; 180))
        {
            AdjustX = cos(EmitAngle) * (-1);
            AdjustY = sin(EmitAngle) * (-1);
        }
        else if((EmitAngle &gt; 180) &amp;&amp; (EmitAngle &lt; 270))
        {
            AdjustX = cos(EmitAngle) * (-1);
            AdjustY = sin(EmitAngle);
        }
        else if((EmitAngle &gt; 270) &amp;&amp; (EmitAngle &lt; 360))
        {
            AdjustX = cos(EmitAngle);
            AdjustY = sin(EmitAngle);
        }
        
        Searching = true;
        //loop through coordinates on line based on angle
        while(Searching)
        {
            i= i + AdjustX;
            j= j + AdjustY;
            
            //if GameObject is found
            if(position_meeting(i,j,obj_GameObject))
            {
                //if GameObject is Emitter and no beams have been drawn yet
                if(object_get_name(instance_position(i,j,obj_GameObject).object_index) == "obj_Emitter" &amp;&amp; EmitCount == 0)
                {
                    //continue;
                }
                //if GameObject is Opaque
                else if(position_meeting(i,j,obj_Opaque))
                {
                    //then assign coordinates
                    EmitArrayX[EmitTracker] = i;
                    EmitArrayY[EmitTracker] = j;
                    EmitTracker++;
                    EmitCount++;
                    
                    //end searching
                    Searching = false;
                    Emitting = true;
                    
                }
                //if GameObject is Reflective
                else if(position_meeting(i,j,obj_Reflective))
                {
                    //then assign coordinates
                    EmitArrayX[EmitTracker] = i;
                    EmitArrayY[EmitTracker] = j;
                    EmitTracker++;
                    EmitCount++;
                    
                    ReflectiveAngle = (instance_position(i,j,obj_Reflective).image_angle);
                    
                    //handle reflection:
                    //determine from which object the light is reflecting
                    //if 2 sided mirror
                    if(object_get_name(instance_position(i,j,obj_Reflective).object_index) == "obj_Mirror_2Sided")
                    {
                        
                        //if difference is 0
                        if((EmitAngle - ReflectiveAngle) == 0)
                        {
                            //end as if opaque (hits the side)
                            Emitting = true;
                        }
                        //if difference is 180
                        else if((EmitAngle - ReflectiveAngle) == 180)
                        {
                            //end as if opaque (hits the side)
                            Emitting = true;
                        }
                        //if difference is 360
                        else if((EmitAngle - ReflectiveAngle) == 360)
                        {
                            //end as if opaque (hits the side)
                            Emitting = true;
                        }
                        //if difference is 90
                        else if((EmitAngle - ReflectiveAngle) == 90)
                        {
                            //end as if opaque (reflects back on itself)
                            Emitting = true;
                        }
                        //if difference is 270
                        else if((EmitAngle - ReflectiveAngle) == 270)
                        {
                            //end as if opaque (reflects back on itself)
                            Emitting = true;
                        }
                        //if difference is from 1 to 89 //quadrant 1
                        else if( ((EmitAngle - ReflectiveAngle) &gt; 0) &amp;&amp; ((EmitAngle - ReflectiveAngle) &lt; 90) )
                        {
                            //if reflecting vertically (quadrant 1 to quandrant 4)
                                //360 - (EmitAngle - (instance_position(i,j,obj_Reflective).image_angle))
                            EmitAngle = (ReflectiveAngle + 360) - (EmitAngle - ReflectiveAngle);
                                //instance_destroy();
                            //from [89,0] to [271,0]
                                //C = (D + 360) - |(A-B)| = (0 + 360) - (89 - 0) = 271
                            //from [1,0] to [359,0]
                                //C = (D + 360) - |(A-B)| = (0 + 360) - (1 - 0) = 359
                                
                            //from [90,45] to [0,45]
                                //C = (D + 360) - |(A-B)| = (45 + 360) - |(90-45)| = 405 - 45 = 360 
                                
                            //if reflecting horizontally (quadrant 1 to quadrant 2)
                                //180 - (EmitAngle - (instance_position(i,j,obj_Reflective).image_angle))
                            
                            //this should never happen:
                                //in cases where the beam strikes the side of the mirror, the object should act as if opaque
                        }
                        //if difference is from 91 to 179 //quadrant 2
                        else if( ((EmitAngle - ReflectiveAngle) &gt; 90) &amp;&amp; ((EmitAngle - ReflectiveAngle) &lt; 180) )
                        {
                            //if reflecting vertically (quadrant 2 to quandrant 3)
                                //180 + (180 - (EmitAngle - (instance_position(i,j,obj_Reflective).image_angle)))
                            EmitAngle = (ReflectiveAngle + 360) - (EmitAngle - ReflectiveAngle);
                                
                             //from [91,0] to [269,360]
                                //C = (D + 360) - |(A-B)| = (0 + 360) - (91 - 0) = 269
                            //from [179,0] to [181,360]
                                //C = (D + 360) - |(A-B)| = (0 + 360) - (179 - 0) = 181
                            
                            //if reflecting horizontally (quadrant 2 to quadrant 1)
                                //0 + (180 - (EmitAngle - (instance_position(i,j,obj_Reflective).image_angle)))
                            
                            //this should never happen:
                                //in cases where the beam strikes the side of the mirror, the object should act as if opaque
                             
                        }
                        //if difference is from 181 to 269 //quadrant 3
                        else if( ((EmitAngle - ReflectiveAngle) &gt; 180) &amp;&amp; ((EmitAngle - ReflectiveAngle) &lt; 270) )
                        {
                            //if reflecting vertically (quadrant 3 to quandrant 2)
                                //90 + (270 - (EmitAngle - (instance_position(i,j,obj_Reflective).image_angle)))
                            EmitAngle = (ReflectiveAngle + 360) - (EmitAngle - ReflectiveAngle);
                                 
                            //from [181,0] to [179,360]
                                //C = (D + 360) - |(A-B)| = (0 + 360) - (181 - 0) = 179
                            //from [269,0] to [91,360]
                                //C = (D + 360) - |(A-B)| = (0 + 360) - (269 - 0) = 91
                                
                            //if reflecting horizontally (quadrant 3 to quadrant 4)
                                //270 + (270 - (EmitAngle - (instance_position(i,j,obj_Reflective).image_angle)))
                            
                            //this should never happen:
                                //in cases where the beam strikes the side of the mirror, the object should act as if opaque
                                        
                        }
                        //if difference is from 271 to 359 //quadrant 4
                        else if( ((EmitAngle - ReflectiveAngle) &gt; 270) &amp;&amp; ((EmitAngle - ReflectiveAngle) &lt; 360) )
                        {
                            //if reflecting vertically (quadrant 4 to quandrant 1)
                                //0 + (360 - (EmitAngle - (instance_position(i,j,obj_Reflective).image_angle)))
                            EmitAngle = (ReflectiveAngle + 360) - (EmitAngle - ReflectiveAngle);
                                
                            //from [271,0] to [89,360]
                                //C = (D + 360) - |(A-B)| = (0 + 360) - (271 - 0) = 89
                            //from [359,0] to [1,360]
                                //C = (D + 360) - |(A-B)| = (0 + 360) - (359 - 0) = 1
                            
                            //if reflecting horizontally (quadrant 4 to quadrant 3)
                                //180 + (360 - (EmitAngle - (instance_position(i,j,obj_Reflective).image_angle)))
                                
                            //this should never happen:
                                //in cases where the beam strikes the side of the mirror, the object should act as if opaque
                        }
                    }   
                    //loop again
                    Searching = false;
                }
                    //instance_destroy();
           }
        }
    }
    //i = obj_Emitter.x;
    //j = obj_Emitter.y;
    //EmitAngle = obj_Emitter.image_angle;
}   
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
