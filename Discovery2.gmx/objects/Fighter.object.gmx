<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_Fighter_down</spriteName>
  <solid>-1</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>Unit</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Destination_x = x;
Destination_y = y;

//determine unit type
Type = 2;
Level = Controller.CurrentLevel[Type];


Selectable = 0;
State = 0;

Description = "Fighting Unit.";

Health = Info.unithealth[Type, Level];
Attack = Info.attack[Type, Level];
Speed = Info.unitspeed[Type, Level];
Value = 0;

Collision = 0;


VISION_RADIUS = Info.Range[2]; //Used in obj_fog_controller to remove the fog
DRAW_FOG = 0 //if true (1), then this object will be drawn beneath the gray fog.
SHOW_VISION = 1 //if false, then the fog around the object will not be removed.

Target = (-1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//sprite resolution

//if stationary
if( State == 0 )
{
    //use down
    sprite_index = spr_Fighter_down;
    //no rotation
    image_speed = 0;
}   
else
{
    //determine direction
    
    //if down
    if( direction &lt; 292.5  &amp;&amp; direction &gt; 247.5 )
    {
        //use down
        sprite_index = spr_Fighter_down;
    }
    //if downleft
    else if( direction &lt; 247.5 &amp;&amp; direction &gt; 202.5 )
    {
        //use up
        sprite_index = spr_Fighter_downleft;
    }
    //if left
    else if( direction &lt; 202.5 &amp;&amp; direction &gt; 157.5 )
    {
        //use up
        sprite_index = spr_Fighter_left;
    }
    //if upleft
    else if( direction &lt; 157.5 &amp;&amp; direction &gt; 112.5 )
    {
        //use up
        sprite_index = spr_Fighter_upleft;
    }
    //if up
    else if( direction &lt; 112.5 &amp;&amp; direction &gt; 67.5 )
    {
        //use up
        sprite_index = spr_Fighter_up;
    }
    //if upright
    else if( direction &lt; 67.5 &amp;&amp; direction &gt; 22.5 )
    {
        //use up
        sprite_index = spr_Fighter_upright;
    }
    //if right
//problem case
    else if( direction &lt; 22.5 || direction &gt; 337.5 )
    {
        //use up
        sprite_index = spr_Fighter_right;
    }
    //if downright
    else if( direction &lt; 337.5 &amp;&amp; direction &gt; 292.5 )
    {
        //use up
        sprite_index = spr_Fighter_downright;
    }
    
    //use image rotation
    image_speed = .25;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if time to upgrade
if( Controller.Upgrade == Type &amp;&amp; Level &lt; Controller.CurrentLevel[Type] )
{
    //Update stats
    Level = Controller.CurrentLevel[Type];     
    Attack = Info.attack[Type, Level];
    Speed = Info.unitspeed[Type, Level];
    
    //Health increases by the difference in level and previous level    
    Health = Health + (Info.unithealth[Type, Level] - Info.unithealth[Type, (Level - 1) ]  );
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Selection Control



//double click selection AND Selected type matches this unit
if( (Controller.DoubleClick == (-1)) &amp;&amp; ((Controller.Selected).Type == Type) )
{
    //if x is in view AND y is in view
    if( (x &gt; view_xview[0] &amp;&amp; x &lt; (view_xview[0]+view_wview[0]) ) &amp;&amp; (y &gt; view_yview[0] &amp;&amp; y &lt; (view_yview[0]+view_hview[0]) ) )
    {
        //test destroy
        //instance_destroy();
        
        Selectable = 1;
        //sprite_index = selected;
        image_alpha = .5;
        Controller.Selected = id;
        instance_create(x, y, Frame);        
    }
}

//drag selection
if( Controller.hold == 2 )
{

//if dragged area is greater than 8 x 8, then use drag selection
if( ((mouse_x - mousx) &gt; 8 || (mouse_x - mousx) &lt; -8) &amp;&amp; ((mouse_y - mousy) &gt; 8 || (mouse_y - mousy) &lt; -8) )
{


    //from the left
    if( x &gt; Controller.mousx &amp;&amp; x &lt; mouse_x )
    {
        //from the top-left
        if( y &gt; Controller.mousy &amp;&amp; y &lt; mouse_y )
        {
            //toggle selected state
            if( Selectable == 1 )
            {
                //Selectable = 0;
                //image_alpha = 1;
                //Controller.Selected = 0;

            }
            else
            {
                Selectable = 1;
                //sprite_index = selected;
                image_alpha = .5;
                Controller.Selected = id;
                instance_create(x, y, Frame);
                
                
            }
        }
        //bottom
        else if( y &lt; Controller.mousy &amp;&amp; y &gt; mouse_y )
        {
            //toggle selected state
            if( Selectable == 1 )
            {
                //Selectable = 0;
                //image_alpha = 1;
                //Controller.Selected = 0;
            }
            else
            {
                Selectable = 1;
                //sprite_index = selected;
                image_alpha = .5;
                Controller.Selected = id;
                instance_create(x, y, Frame);
            }
        }
        else
        {
            Selectable = 0;
            image_alpha = 1;
            Controller.Selected = 0;
        }
    }
    //right
    else if( x &lt; Controller.mousx &amp;&amp; x &gt; mouse_x )
    {
        //top
        if( y &gt; Controller.mousy &amp;&amp; y &lt; mouse_y )
        {
            //toggle selected state
            if( Selectable == 1 )
            {
                //Selectable = 0;
                //image_alpha = 1;
                //Controller.Selected = 0;
            }
            else
            {
                Selectable = 1;
                //sprite_index = selected;
                image_alpha = .5;
                Controller.Selected = id;
                instance_create(x, y, Frame);
            }
        }
        //bottom
        else if( y &lt; Controller.mousy &amp;&amp; y &gt; mouse_y )
        {
            //toggle selected state
            if( Selectable == 1 )
            {
                //Selectable = 0;
                //image_alpha = 1;
                //Controller.Selected = 0;
            }
            else
            {
                Selectable = 1;
                //sprite_index = selected;
                image_alpha = .5;
                Controller.Selected = id;
                instance_create(x, y, Frame);
            }
        }
        else
        {
            Selectable = 0;
            image_alpha = 1;
            Controller.Selected = 0;
        }
    }
    else
    {
        Selectable = 0;
        image_alpha = 1;
        Controller.Selected = 0;
    }   
} 

}


if( Controller.Selected == 0 )
{
    //if selected
    if( Selectable == 1 )
    {
        Controller.Selected = id;
    }   
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if put in a "Pre-Built" State
if( State == 9 )
{
    if( place_meeting(x, y, Friendly) == true || distance_to(Collision) &lt; 2 )
    {
        //if solid
        if( solid == 1)
        {
            solid = 0;
        }
    
        //move_away(Collision, Speed);
    
        //Set Destination to distance betwen objects on the opposite side

        //object is at same spot
        if( (x == (Collision).x) &amp;&amp; (y == (Collision).y) )
        {
            //direction = random(1) * 360;
            x = x + random(8);
            //speed = Speed;
        }
        else
        {
            //if vertically aligned
            if( x == (Collision).x )
            {
                //if directly above target
                if( y &lt; (Collision).y)
                {
                    //move up
                    move_towards_point(x, y-((Collision).y-y), Speed);
                }
                //if directly below target
                else if( y &gt; (Collision.y) )
                {
                    //move down
                    move_towards_point(x, y+(y-(Collision).y), Speed);
                }
                    
            }
            else if( y == (Collision).y )
            {
                //if directly right of target
                if( x &gt; (Collision).x)
                {
                    //move right
                    move_towards_point(x+(x-(Collision).x), y, Speed);
                }            
                //if directly left of target
                else if( x &lt; (Collision).x)
                {
                    //move left
                    move_towards_point(x-((Collision).x-x), y, Speed);
                }
            }
            //if right and below
            else if( x &gt; (Collision).x &amp;&amp; y &gt; (Collision).y )
            {
                move_towards_point(x+(x-(Collision).x), y+(y-(Collision).y), Speed);
            }
            //if right and above
            else if( x &gt; (Collision).x &amp;&amp; y &lt; (Collision).y )
            {
                move_towards_point(x+(x-(Collision).x), y-((Collision).y-y), Speed);
            }
            //if left and below
            else if( x &lt; (Collision).x &amp;&amp; y &gt; (Collision).y )
            {
                move_towards_point(x-((Collision).x-x), y+(y-(Collision).y), Speed);
            }
            //if left and above
            else if( x &lt; (Collision).x &amp;&amp; y &lt; (Collision).y )
            {
                move_towards_point(x-((Collision).x-x), y-((Collision).y-y), Speed);
            }
        
        
        
              
        }
        
        //instance_destroy();
        //move_towards_point(Destination_x, Destination_y, Speed);
                 
        
    }
    else
    {
        //instance_destroy();
        solid = 1;
        State = 1;
        motion_set(0, 0);
        
        //Destination_x = x;
        //Destination_y = y;
        
        Collision = 0;
    }
    
}
else
{

    //Command destination resolution
        //if Unit is selected AND Command is being issued AND new destination is being set
    if( Selectable == 1 &amp;&amp; Controller.Command == 1 &amp;&amp; Controller.Destination_x != (-1) &amp;&amp; Controller.Destination_y != (-1) )
    {
        //pass destination to unit
        Destination_x = Controller.Destination_x;
        Destination_y = Controller.Destination_y;
        
        //if command is an attack or move
        if( Controller.Option == 12 || Controller.Option == 0)
        {
            //if there is a Enemy close enough to destination at time of designation
                //requires a distance from point
            if( distance_from( Destination_x, Destination_y, instance_nearest(Destination_x, Destination_y, AllBad))  &lt; Info.Range[0] )
            {
                //instance_destroy();
                Target = instance_nearest(Destination_x, Destination_y, AllBad);
            }
            else
            {
                Target = (-1);
            }
            
            //Change state to moving
            State = 1;
        }
        
    }

    //State Based resolution    
        //if State equals 0
    if( State == 0 )
    {    
        //find nearest AllBad in aggro range
            //set destination to the NEAREST
                //if Attacker is "Ready"
                //AND AllBads exist
                //AND Fighter is not already targetting an enemy
        if( distance_to_object(AllBad) &lt; Info.Range[2] &amp;&amp; (State == 0) &amp;&amp; instance_number(AllBad) &gt; 0 &amp;&amp; Target == (-1))
        {
            Target = instance_nearest(x, y, AllBad);
            //Destination_x = (Target).x;
            //Destination_y = (Target).y;
            //Destination_x = (instance_nearest(x, y, AllBad)).x;
            //Destination_y = (instance_nearest(x, y, AllBad)).y;
        }
        
        //if Targetting a destructible and not in range
            //requires distance_to specific object
        if( Target != (-1) &amp;&amp; (distance_to(Target) &gt; Info.Range[0]) )
        {
            //Change state to moving
            State = 1;

            Destination_x = (Target).x;
            Destination_y = (Target).y;
        }
    
    }
 
    //if State equals 1
    if( State == 1 )
    {
        //if not at destination (or within one jump)
        if( ((x &lt; Destination_x-(Speed-(Speed/10))) || (x &gt; Destination_x + (Speed/10))) || ((y &lt; Destination_y - (Speed/10)) || (y &gt; Destination_y + (Speed/10))) &amp;&amp; (Destination_x != 0 &amp;&amp; Destination_y != 0) )
        {

            State = 1;
            //good method to move unit
            //if( ((distance_to_object(Monster_Maker_d) &lt; 2) &amp;&amp; (place_meeting(Destination_x, Destination_y, Monster_Maker_d))) || ((distance_to_object(Baddy) &lt; 2) &amp;&amp; (place_meeting(Destination_x, Destination_y, Baddy))) )
            if( (Target != (-1)) &amp;&amp; (distance_to(Target) &lt; 2) )
            {
                move_towards_point(Destination_x, Destination_y, Speed/*Info.unitspeed[Type, Level]*/);
            }
            else
            {
                mp_potential_step(Destination_x, Destination_y, Speed/*Info.unitspeed[Type, Level]*/, false);
            }
        }
        else //if(State == 1)//if( x == Destination_x &amp;&amp; y == Destination_y )
        {
            State = 0;
            motion_set(0, 0);
    
            Destination_x = x;
            Destination_y = y;
    
            //image_alpha = 1;
            //Selectable = 0;
        }
    
        //if Attacker is moving or "ready" AND close enough to Target AND there is a Target
        if( /*(State == 0 || State == 1) &amp;&amp;*/ Target != (-1) &amp;&amp; collision_with(Target) )//(distance_to(Target) &lt; Info.Range[0])  )
        {
            //change state to "attacking"
            State = 4;
        }
    }
    
    //if "attacking" AND has a Target AND attacker is NOT being told to move away
        //requires a collision check for specific object
    //if( State == 4 &amp;&amp; Target != 0 &amp;&amp; (place_meeting(Destination_x, Destination_y, (Target)) == true) )
    //if( State == 4 &amp;&amp; Target != (-1) )//&amp;&amp; (collision_with((Target)) == true) )
    if( State == 4 )//&amp;&amp; Target != (-1) )//&amp;&amp; (collision_with((Target)) == true) )
    {
        //if the destructible's current health - attacker's attack (/room_speed for "per step") is MORE THAN OR EQUAL TO 0
            //if( destrucible.health - attacker.attack per sec &gt;= 0 )
        if( ((Target).Health - Attack/room_speed &gt; 0 ) )
        {
            //decrement Resource's value
            (Target).Health = (Target).Health - (Attack/room_speed);
        
        }
        //if decrement would excede enemy's available health
        else if( ((Target).Health - Attack/room_speed &lt;= 0 ) )
        {
            //decrement enemy health to 0
            (Target).Health = 0;
            (Target).State = 8;
        
            Target = (-1);
        
            State = 0;    
            motion_set(0, 0);
        
        
            Destination_x = x;
            Destination_y = y;
        }
    }
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Destruction Resolution

if( State == 8 || Health == 0 )
{
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="AllBad">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if an "AllBad" destructible AND Attacker is ready OR Moving
    //AND distance from destination to target is &lt; 1/2 Target's sprite width
if( (State == 0 || State == 1) )// &amp;&amp; ( sqrt( sqr(Destination_x - (Target).x) + sqr(Destination_y - (Target).y) &lt; ((Target).sprite_width/2) )  ) )
{
    //if other's Type matches available Types
    if( (other).Type == 3 || (other).Type == 19 )
    {
    
        //prioritize Baddys
        if( (other).Type == 3 )
        {
            //Target = (other).id;
        }
        else if( (other).Type == 19 )
        {
            //Target = (other).id;
        }    
        
        //change state to "Attacking"
        State = 4;
        
        //Destination_x = (Target).x;
        //Destination_y = (Target).y;
    }
    
    
        
    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
