<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_Monster_down</spriteName>
  <solid>-1</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>Baddy</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Destination_x = x;
Destination_y = y;

//determine unit type
Type = 3;
Level = Controller.CurrentLevel[Type];


Selectable = 0;
State = 0;
//State = 9;
Description = "Scary Monster.";
Health = Info.unithealth[Type, Level];
Attack = Info.attack[Type, Level];
Speed = Info.unitspeed[Type, Level];
Value = 0;

Collision = 0;

//if this is 0 they become invisible regardless
DRAW_FOG = 0 //if true (1), then this object will be drawn beneath the gray fog.
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//sprite resolution

//if stationary
//if( speed == 0 )
//{
    //use down
    //sprite_index = spr_Monster_down;
    //no rotation
    //image_speed = 0;
//}   
//else
//else
//{
    //determine direction
    
    //if down
    if( direction &lt; 292.5  &amp;&amp; direction &gt; 247.5 )
    {
        //use down
        sprite_index = spr_Monster_down;
    }
    //if downleft
    else if( direction &lt; 247.5 &amp;&amp; direction &gt; 202.5 )
    {
        //use up
        sprite_index = spr_Monster_downleft;
    }
    //if left
    else if( direction &lt; 202.5 &amp;&amp; direction &gt; 157.5 )
    {
        //use up
        sprite_index = spr_Monster_left;
    }
    //if upleft
    else if( direction &lt; 157.5 &amp;&amp; direction &gt; 112.5 )
    {
        //use up
        sprite_index = spr_Monster_upleft;
    }
    //if up
    else if( direction &lt; 112.5 &amp;&amp; direction &gt; 67.5 )
    {
        //use up
        sprite_index = spr_Monster_up;
    }
    //if upright
    else if( direction &lt; 67.5 &amp;&amp; direction &gt; 22.5 )
    {
        //use up
        sprite_index = spr_Monster_upright;
    }
    //if right
//problem case
    else if( direction &lt; 22.5 || direction &gt; 337.5 )
    {
        //use up
        sprite_index = spr_Monster_right;
    }
    //if downright
    else if( direction &lt; 337.5 &amp;&amp; direction &gt; 292.5 )
    {
        //use up
        sprite_index = spr_Monster_downright;
    }
    
    //use image rotation
    image_speed = .25;
//}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Selection Control
if( Controller.Selected == 0 )
{
    //if selected
    if( Selectable == 1 )
    {
        Controller.Selected = id;
    }   
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if put in a "Pre-Built" State
if( State == 9 )
{
    if( place_meeting(x, y, AllBad) == true || (Collision != 0 &amp;&amp; distance_to(Collision) &lt; 2) )
    {
        //if solid
        if( solid == 1)
        {
            solid = 0;
        }
    
        //move_away(Collision, Speed);
    
        //Set Destination to distance betwen objects on the opposite side

        //object is at same spot
        if( (x == (Collision).x) &amp;&amp; (y == (Collision).y) )
        {
            //direction = random(1) * 360;
            x = x + random(8);
            //speed = Speed;
        }
        else
        {
            //if vertically aligned
            if( x == (Collision).x )
            {
                //if directly above target
                if( y &lt; (Collision).y)
                {
                    //move up
                    move_towards_point(x, y-((Collision).y-y), Speed);
                }
                //if directly below target
                else if( y &gt; (Collision.y) )
                {
                    //move down
                    move_towards_point(x, y+(y-(Collision).y), Speed);
                }
                    
            }
            else if( y == (Collision).y )
            {
                //if directly right of target
                if( x &gt; (Collision).x)
                {
                    //move right
                    move_towards_point(x+(x-(Collision).x), y, Speed);
                }            
                //if directly left of target
                else if( x &lt; (Collision).x)
                {
                    //move left
                    move_towards_point(x-((Collision).x-x), y, Speed);
                }
            }
            //if right and below
            else if( x &gt; (Collision).x &amp;&amp; y &gt; (Collision).y )
            {
                move_towards_point(x+(x-(Collision).x), y+(y-(Collision).y), Speed);
            }
            //if right and above
            else if( x &gt; (Collision).x &amp;&amp; y &lt; (Collision).y )
            {
                move_towards_point(x+(x-(Collision).x), y-((Collision).y-y), Speed);
            }
            //if left and below
            else if( x &lt; (Collision).x &amp;&amp; y &gt; (Collision).y )
            {
                move_towards_point(x-((Collision).x-x), y+(y-(Collision).y), Speed);
            }
            //if left and above
            else if( x &lt; (Collision).x &amp;&amp; y &lt; (Collision).y )
            {
                move_towards_point(x-((Collision).x-x), y-((Collision).y-y), Speed);
            }
        }
        
        //instance_destroy();
        //move_towards_point(Destination_x, Destination_y, Speed);
    }
    else
    {
        //instance_destroy();
        solid = 1;
        State = 0;
        motion_set(0, 0);
        
        //Destination_x = x;
        //Destination_y = y;
        
        Collision = 0;
    }
    
}
else
{
    //State Based resolution    
        //if State equals 0
    if( State == 0 )
    {
        //find nearest building or unit
            //set destination to the NEAREST
                //if Monster is "Ready" or "Moving"
                //AND Buildings exist
            //prioritizes building
        if( distance_to_object(Building) &lt;= distance_to_object(Unit)  &amp;&amp; instance_number(Building) &gt; 0 ) //&amp;&amp; (State == 0 || State == 1)
        {
            //Destination_x = (instance_nearest(x, y, Building)).x;
            //Destination_y = (instance_nearest(x, y, Building)).y;
            Target = instance_nearest(x,y, Building);
            Destination_x = (Target).x;
            Destination_y = (Target).y;
            
            State = 1;
        }
        else if( instance_number(Unit) &gt; 0 )//&amp;&amp; State == 0 || State == 1 )
        {
            //Destination_x = (instance_nearest(x, y, Unit)).x;
            //Destination_y = (instance_nearest(x, y, Unit)).y;  
    
            Target = instance_nearest(x,y, Unit);
            Destination_x = (Target).x;
            Destination_y = (Target).y;
            
            State = 1;
        }
    }

    //if State equals 1
    if( State == 1 )
    {
        //move towards nearest object
            //if not at destination (or within one jump)
        if( ((x &lt; Destination_x-(Speed-(Speed/10))) || (x &gt; Destination_x + (Speed/10))) || ((y &lt; Destination_y - (Speed/10)) || (y &gt; Destination_y + (Speed/10))) &amp;&amp; (Destination_x != 0 &amp;&amp; Destination_y != 0) )
        {

            //good method to move unit
            //if( distance_to_object(Friendly) &lt; 2 )
            if( distance_to(Target) &lt; 2 )
            {
                move_towards_point(Destination_x, Destination_y, Speed );
            }
            else
            {
                mp_potential_step(Destination_x, Destination_y, Speed, false);
            }
        }
        else //if(State == 1)//if( x == Destination_x &amp;&amp; y == Destination_y )
        {
            State = 0;
            motion_set(0, 0);
    
            Destination_x = x;
            Destination_y = y;
    
            //image_alpha = 1;
            //Selectable = 0;
        }

        //if Attacker is moving or "ready" AND close enough to Target AND there is a Target
        if( /*(State == 0 || State == 1) &amp;&amp;*/ Target != 0 &amp;&amp; collision_with(Target) ) //(distance_to(Target) &lt; Info.Range[0]) )
        {
            //change state to "attacking"
            State = 4;
        }
    }

    //if "attacking" AND has a Target AND attacker is NOT being told to move away
    //if( State == 4 &amp;&amp; Target != 0 &amp;&amp; (place_meeting(Destination_x, Destination_y, (Target)) == true) )
    if( State == 4 )//&amp;&amp; Target != 0 &amp;&amp; (collision_with((Target)) == true) )
    {
        //if the destructible's current health - attacker's attack (/room_speed for "per step") is MORE THAN OR EQUAL TO 0
        //if( destrucible.health - attacker.attack per sec &gt;= 0 )
        if( ((Target).Health - Attack/room_speed &gt; 0 ) )
        {
            //decrement Resource's value
            (Target).Health = (Target).Health - (Attack/room_speed);
        }
        //if decrement would excede Resource's available value
        else if( ((Target).Health - Attack/room_speed &lt;= 0 ) )
        {
        
            if( Target != (-1) )
            {
                //decrement Resource's value to 0
                (Target).Health = 0;
                (Target).State = 8;
            }
        
            Target = (-1);
            State = 0;
            motion_set(0, 0);
        
            Destination_x = x;
            Destination_y = y;
        }
    }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Destruction Resolution

if( State == 8 || Health == 0 )
{
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="Friendly">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//If not Dying AND not already Attacking
if(State != 8 &amp;&amp; State != 4)
{

    //if "bad" destructible AND Attacker is ready OR Moving
    if( (State == 0 || State == 1) &amp;&amp; place_meeting(x,y, Monster) == false )
    {
        //if making contact with a Friendly
        if( other.Type &gt;= 0 &amp;&amp; other.type &lt;= 2 || (other.Type &gt;= 4 &amp;&amp; other.Type &lt;=8) || (other.Type &gt;= 10 &amp;&amp; other.Type &lt;=15) )
        {
            //instance_destroy();
            //Target = other.id;
            //change state to "Attacking"
            State = 4;
    
            //Destination_x = (Target).x;
            //Destination_y = (Target).y;    
        }
    }


}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="AllBad">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if( State != 8 &amp;&amp; State != 4 )
{


//change state to "Pre-Built"
State = 9;
solid = 0;

//if having collision with a Baddy OR Bad
if( (other).Type == 3 || (other).Type == 9 || (other).Type == 19 )
{
    //Destination_x = (other).x;
    //Destination_y = (other).y;
    
    Collision = (other).id;
}

}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
