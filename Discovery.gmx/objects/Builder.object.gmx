<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_Builder_down</spriteName>
  <solid>-1</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>Unit</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Destination_x = x;
Destination_y = y;

//determine unit type
Type = 0;
Level = Controller.CurrentLevel[Type];

Selectable = 0;
State = 0;

Description = "Builder Unit.";

Health = Info.unithealth[Type, Level];
Attack = Info.attack[Type, Level];
Speed = Info.unitspeed[Type, Level];
Value = 0;

Collision = 0;


VISION_RADIUS = Info.Range[2]; //Used in obj_fog_controller to remove the fog
DRAW_FOG = 0 //if true (1), then this object will be drawn beneath the gray fog.
SHOW_VISION = 1 //if false, then the fog around the object will not be removed.

Target = (-1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//sprite resolution

//if stationary
if( State == 0 )
{
    //use down
    sprite_index = spr_Builder_down;
    //image_index = 1;
    //no rotation
    image_speed = 0;
}   
else
{
    //determine direction
    
    //if down
    if( direction &lt; 292.5  &amp;&amp; direction &gt; 247.5 )
    {
        //use down
        sprite_index = spr_Builder_down;
    }
    //if downleft
    else if( direction &lt; 247.5 &amp;&amp; direction &gt; 202.5 )
    {
        //use up
        sprite_index = spr_Builder_downleft;
    }
    //if left
    else if( direction &lt; 202.5 &amp;&amp; direction &gt; 157.5 )
    {
        //use up
        sprite_index = spr_Builder_left;
    }
    //if upleft
    else if( direction &lt; 157.5 &amp;&amp; direction &gt; 112.5 )
    {
        //use up
        sprite_index = spr_Builder_upleft;
    }
    //if up
    else if( direction &lt; 112.5 &amp;&amp; direction &gt; 67.5 )
    {
        //use up
        sprite_index = spr_Builder_up;
    }
    //if upright
    else if( direction &lt; 67.5 &amp;&amp; direction &gt; 22.5 )
    {
        //use up
        sprite_index = spr_Builder_upright;
    }
    //if right
//problem case
    else if( direction &lt; 22.5 || direction &gt; 337.5 )
    {
        //use up
        sprite_index = spr_Builder_right;
    }
    //if downright
    else if( direction &lt; 337.5 &amp;&amp; direction &gt; 292.5 )
    {
        //use up
        sprite_index = spr_Builder_downright;
    }
    
    //use image rotation
    image_speed = .25;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if time to upgrade AND Level is less than Current Available Level
if( Controller.Upgrade == Type &amp;&amp; Level &lt; Controller.CurrentLevel[Type] )
{
    //Update stats
    Level = Controller.CurrentLevel[Type];     
    Attack = Info.attack[Type, Level];
    Speed = Info.unitspeed[Type, Level];
    
    //Health increases by the difference in level and previous level    
    Health = Health + (Info.unithealth[Type, Level] - Info.unithealth[Type, (Level - 1) ]  );
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Selection Control



//double click selection AND Selected type matches this unit
if( (Controller.DoubleClick == (-1)) &amp;&amp; ((Controller.Selected).Type == Type) )
{
    //if x is in view AND y is in view
    if( (x &gt; view_xview[0] &amp;&amp; x &lt; (view_xview[0]+view_wview[0]) ) &amp;&amp; (y &gt; view_yview[0] &amp;&amp; y &lt; (view_yview[0]+view_hview[0]) ) )
    {
        //test destroy
        //instance_destroy();
        
        Selectable = 1;
        //sprite_index = selected;
        image_alpha = .5;
        Controller.Selected = id;
        instance_create(x, y, Frame);        
    }
}



//drag selection
if( Controller.hold == 2 )
{

//if dragged area is greater than 8 x 8, then use drag selection
if( ((mouse_x - mousx) &gt; 8 || (mouse_x - mousx) &lt; -8) &amp;&amp; ((mouse_y - mousy) &gt; 8 || (mouse_y - mousy) &lt; -8) )
{
    //from the left
    if( x &gt; Controller.mousx &amp;&amp; x &lt; mouse_x )
    {
        //from the top-left
        if( y &gt; Controller.mousy &amp;&amp; y &lt; mouse_y )
        {
            //toggle selected state
            if( Selectable == 1 )
            {
                //Selectable = 0;
                //image_alpha = 1;
                //Controller.Selected = 0;
            }
            else
            {
                Selectable = 1;
                //sprite_index = selected;
                image_alpha = .5;
                Controller.Selected = id;
                instance_create(x, y, Frame);
                
                
            }
        }
        //bottom
        else if( y &lt; Controller.mousy &amp;&amp; y &gt; mouse_y )
        {
            //toggle selected state
            if( Selectable == 1 )
            {
                //Selectable = 0;
                //image_alpha = 1;
                //Controller.Selected = 0;
            }
            else
            {
                Selectable = 1;
                //sprite_index = selected;
                image_alpha = .5;
                Controller.Selected = id;
                instance_create(x, y, Frame);
            }
        }
        else
        {
            Selectable = 0;
            image_alpha = 1;
            Controller.Selected = 0;
        }
    }
    //right
    else if( x &lt; Controller.mousx &amp;&amp; x &gt; mouse_x )
    {
        //top
        if( y &gt; Controller.mousy &amp;&amp; y &lt; mouse_y )
        {
            //toggle selected state
            if( Selectable == 1 )
            {
                //Selectable = 0;
                //image_alpha = 1;
                //Controller.Selected = 0;
            }
            else
            {
                Selectable = 1;
                //sprite_index = selected;
                image_alpha = .5;
                Controller.Selected = id;
                instance_create(x, y, Frame);
            }
        }
        //bottom
        else if( y &lt; Controller.mousy &amp;&amp; y &gt; mouse_y )
        {
            //toggle selected state
            if( Selectable == 1 )
            {
                //Selectable = 0;
                //image_alpha = 1;
                //Controller.Selected = 0;
            }
            else
            {
                Selectable = 1;
                //sprite_index = selected;
                image_alpha = .5;
                Controller.Selected = id;
                instance_create(x, y, Frame);
            }
        }
        else
        {
            Selectable = 0;
            image_alpha = 1;
            Controller.Selected = 0;
        }
    }
    else
    {
        Selectable = 0;
        image_alpha = 1;
        Controller.Selected = 0;
    }   
} 

}

if( Controller.Selected == 0 )
{
    //if selected
    if( Selectable == 1 )
    {
        Controller.Selected = id;
    }   
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if put in a "Pre-Built" State
if( State == 9 )
{
    if( place_meeting(x, y, Friendly) == true || distance_to(Collision) &lt; 2 )
    {
        //if solid
        if( solid == 1)
        {
            solid = 0;
        }
    
        //move_away(Collision, Speed);
    
        //Set Destination to distance betwen objects on the opposite side

        //object is at same spot
        if( (x == (Collision).x) &amp;&amp; (y == (Collision).y) )
        {
            //direction = random(1) * 360;
            x = x + random(8);
            //speed = Speed;
        }
        else
        {
            //if vertically aligned
            if( x == (Collision).x )
            {
                //if directly above target
                if( y &lt; (Collision).y)
                {
                    //move up
                    move_towards_point(x, y-((Collision).y-y), Speed);
                }
                //if directly below target
                else if( y &gt; (Collision.y) )
                {
                    //move down
                    move_towards_point(x, y+(y-(Collision).y), Speed);
                }
                    
            }
            else if( y == (Collision).y )
            {
                //if directly right of target
                if( x &gt; (Collision).x)
                {
                    //move right
                    move_towards_point(x+(x-(Collision).x), y, Speed);
                }            
                //if directly left of target
                else if( x &lt; (Collision).x)
                {
                    //move left
                    move_towards_point(x-((Collision).x-x), y, Speed);
                }
            }
            //if right and below
            else if( x &gt; (Collision).x &amp;&amp; y &gt; (Collision).y )
            {
                move_towards_point(x+(x-(Collision).x), y+(y-(Collision).y), Speed);
            }
            //if right and above
            else if( x &gt; (Collision).x &amp;&amp; y &lt; (Collision).y )
            {
                move_towards_point(x+(x-(Collision).x), y-((Collision).y-y), Speed);
            }
            //if left and below
            else if( x &lt; (Collision).x &amp;&amp; y &gt; (Collision).y )
            {
                move_towards_point(x-((Collision).x-x), y+(y-(Collision).y), Speed);
            }
            //if left and above
            else if( x &lt; (Collision).x &amp;&amp; y &lt; (Collision).y )
            {
                move_towards_point(x-((Collision).x-x), y-((Collision).y-y), Speed);
            }
        
        
        
              
        }
        
        //instance_destroy();
        //move_towards_point(Destination_x, Destination_y, Speed);
         
                
        
    }
    else
    {
        //instance_destroy();
        solid = 1;
        State = 1;
        motion_set(0, 0);
        
        //Destination_x = x;
        //Destination_y = y;
        
        Collision = 0;
    }
    
}
else
{


    //Command destination resolution
        //if Unit is selected AND Command is being issued AND new destination is being set
    if( Selectable == 1 &amp;&amp; Controller.Command == 1 &amp;&amp; Controller.Destination_x != (-1) &amp;&amp; Controller.Destination_y != (-1) )
    {
        Destination_x = Controller.Destination_x;
        Destination_y = Controller.Destination_y;
                
        //if command is a repair or move or any build any Building **Note** Tower upgrades are not build directly
        if( Controller.Option == 25 || Controller.Option == 0 || (Controller.Option &gt;= 1 &amp;&amp; Controller.Option &lt;= 7) )
        {
            //if there is a Builing close enough to destination at time of designation
                //requires a distance from point
            if( distance_from( Destination_x, Destination_y, instance_nearest(Destination_x, Destination_y, Building))  &lt; Info.Range[0] )
            {
                Target = instance_nearest(Destination_x, Destination_y, Building);
            }
            else
            {
                Target = (-1);
            }
            
            //Change state to moving
            State = 1;
        }
    }

    //State Based resolution    
        //if State equals 0
    if( State == 0 )
    {
        //if Targetting a building and not in range
            //requires distance_to specific object
        if( Target != (-1) &amp;&amp; (distance_to(Target) &gt; Info.Range[0]) )
        {
            Destination_x = (Target).x;
            Destination_y = (Target).y;
            
            //Change state to moving
            State = 1;
        }
    }
    
    //if State equals 1
    if( State == 1 )
    {
        //if not at destination
        if( ((x &lt; Destination_x-(Speed-(Speed/10))) || (x &gt; Destination_x + (Speed/10))) || ((y &lt; Destination_y - (Speed/10)) || (y &gt; Destination_y + (Speed/10))) &amp;&amp; (Destination_x != 0 &amp;&amp; Destination_y != 0) )
        {
            //change State to "Moving"
            //State = 1;
        
            //good method to move unit
                //if Builder is within 2 pixels of the Target
            if( (Target != (-1)) &amp;&amp; (distance_to(Target) &lt; 2) )
            {
                move_towards_point(Destination_x, Destination_y, Speed);
            }
            else
            {
                mp_potential_step(Destination_x, Destination_y, Speed, false);
            }
        }
        else// if( State == 1)//x == Destination_x &amp;&amp; y == Destination_y &amp;&amp;  )
        {
            State = 0;
            motion_set(0, 0);
    
            Destination_x = x;
            Destination_y = y;
    
            //image_alpha = 1;
            //Selectable = 0;
        }

        //if Builder is moving or "ready" AND close enough to Target AND there is a Target
            //requires a distance_to specific target method
            //AND Target is at less than full health
        if( /*(State == 0 || State == 1) &amp;&amp;*/ Target != (-1) &amp;&amp; (Target).Health &lt; Info.unithealth[(Target).Type, (Target).Level] &amp;&amp; (collision_with((Target)) == true) )//(distance_to(Target) &lt; Info.Range[0]))
        {
            //change state to "building"
            State = 2;
        }
    }
    
    //if "attacking" AND has a Target AND attacker is NOT being told to move away
    //if( State == 2 &amp;&amp; Target != (-1) )//&amp;&amp; (place_meeting(Destination_x, Destination_y, (Target)) == true) )
    if( State == 2 )//&amp;&amp; Target != (-1) )//&amp;&amp; (place_meeting(Destination_x, Destination_y, (Target)) == true) )
    {
        //if the building's current health + builder's attack (/room_speed for "per step") is LESS THAN OR EQUAL TO building's health
            //if( building.health + builder.attack per sec &gt;= 0 )
        if( ((Target).Health + Attack/room_speed &lt; Info.unithealth[(Target).Type, (Target).Level] ) )
        {
            //increment building's health
            (Target).Health = (Target).Health + (Attack/room_speed);
        }
        //if increment would excede Builing's maximum health
        else if( ((Target).Health + Attack/room_speed &gt;= Info.unithealth[(Target).Type, (Target).Level] ) )
        {
            //increment target's value to full health
            (Target).Health = Info.unithealth[(Target).Type, (Target).Level];
            (Target).State = 0;
            State = 0;
            motion_set(0, 0);
        
            Destination_x = x;
            Destination_y = y;
            
            //if HQ_Building
            if( (Target).Type == 4 )
            {
                (Target).VISION_RADIUS = Info.Range[3]; //Used in obj_fog_controller to remove the fog
            }
            else
            {            
                (Target).VISION_RADIUS = Info.Range[2]; //Used in obj_fog_controller to remove the fog
            }
        
            //remove builder from building
            Collision = Target;
            State = 9;
            Target = (-1);
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Destruction Resolution

if( State == 8 || Health == 0 )
{
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="Building">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
//if there is a collision of with Building
//if( place_meeting(x, y, Building) )//&amp;&amp; (other.id) == Target )
{
    //if Builder is ready OR Moving AND Building is not "Pre-Built"
    if( (State == 0 || State == 1 ) &amp;&amp; ( other.State != 9 ) )
    {
        //if colliding with a building
        //if( ((other).Type &gt;= 4 &amp;&amp; (other).Type &lt;= 8) || ((other).Type &gt;= 10 &amp;&amp; (other).Type &lt;= 15) )
        //{
            //instance_destroy();
           Target = (other.id);
        
            //change state to "Building"
            State = 2;
            
            //Destination_x = x;
            //Destination_y = y;
        
            //Destination_x = (Target).x;
            //Destination_y = (Target).y;
        //}
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
