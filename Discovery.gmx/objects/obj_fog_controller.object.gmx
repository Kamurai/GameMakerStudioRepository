<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1</depth>
  <persistent>0</persistent>
  <parentName>Interface_Object</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/* 
** First, determine the size of the surface being used. Ideally, we want
** this to be proportional to the room's width and height. We can maintain this
** proportion by defining only the X size of the grid. We do have to make sure,
** however, that the surface size doesn't exceed what most graphics cards can
** display. This isn't taken into consideration here, but rather should be
** taken into consideration when developing your rooms. Conversely, the smaller 
** the surface size, the larger the number of surfaces that is used, and thus
** more memory may be used.
*/

SIZE_W = room_width//2528
SIZE_H = SIZE_W * room_height / room_width

/* 
** Next, we want to create two grids that contain the minimum number amout of 
** tiles of the above size to cover the entire room. Each cell contains a
** surface of the above dimensions. The first grid serves as the one-time
** black fog of war where nothing is visible, and the second grid contains
** the gray fog, which only conceals units. 
*/


var i, j, surface;
FOG_GRID_WIDTH = room_width div SIZE_W //+ 1 //See NOTE 1 at the bottom
FOG_GRID_HEIGHT = room_height div SIZE_H //+ 1
FOG_GRID_BLACK = ds_grid_create(FOG_GRID_WIDTH, FOG_GRID_HEIGHT )
FOG_GRID_GRAY = ds_grid_create(FOG_GRID_WIDTH, FOG_GRID_HEIGHT )
for (i=0; i&lt;FOG_GRID_WIDTH; i+=1)
for (j=0; j&lt;FOG_GRID_HEIGHT; j+=1)
{
    surface = surface_create(SIZE_W, SIZE_H)
    ds_grid_set(FOG_GRID_BLACK, i, j, surface)
    surface_set_target(surface)
    draw_clear(c_black)
    
    surface = surface_create(SIZE_W, SIZE_H)
    ds_grid_set(FOG_GRID_GRAY, i, j, surface)
    surface_set_target(surface)
    draw_clear(c_gray)
}
surface_reset_target()

/*
** We also should determine how often the fog of war updates. Unless you want
** an extremely detailed, and potentially extremely laggy, game then you should
** have the fog of war update every several steps, rather than once every step.
** A good idea is to choose the number of times the fog of war should update
** per second, and then use that along with room_speed to calculate how many
** steps there should be in an alarm. This example has an alarm that updates
** five times per second.
*/

FOG_UPDATE_PERIOD = room_speed //div 5
alarm[0] = FOG_UPDATE_PERIOD

/* NOTE 1
** If SIZE_W evenly divides room_width, then you can remove the "+ 1" after 
** "room_width div SIZE_W". The same can also be done with the height. By not
** doing this, you may be using more surfaces than you need to be using.
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
** When the fog controller is destroyed, we need to free up the memory used
** by the surfaces and the gridd.
*/

var i, j;
for (i=0;i&lt;FOG_WIDTH_WIDTH; i+= 1)
for (j=0;i&lt;FOG_WIDTH_HEIGHT; j+=1)
{
    surface_free(ds_grid_get(FOG_GRID_BLACK, i, j))
    surface_free(ds_grid_get(FOG_GRID_GRAY, i, j))
}
ds_grid_destroy(FOG_GRID_BLACK)
ds_grid_destroy(FOG_GRID_GRAY)</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
** This is the alarm that is used to periodically update the fog. As
** this script is periodic in nature, the first thing we should do is
** set the value of the alarm to the update period.
*/

alarm[0] = FOG_UPDATE_PERIOD

/* We want to reset the gray fog to its normal state because it regenerates
** in areas that units cannot see. The black fog does not regenerate, and
** is not included here. The surface is reset later in the script, after
** other surface alterations have been done.
*/

for (i=0; i&lt;FOG_GRID_WIDTH; i+=1)
for (j=0; j&lt;FOG_GRID_HEIGHT; j+=1)
{  
    surface_set_target(ds_grid_get(FOG_GRID_GRAY, i, j))
    draw_clear(c_gray)
}

//We need to set the visibility of all objects that aren't in drawn
//in the gray fog to zero.

//with (obj_revealer_parent)
with (Friendly)
{
    if (DRAW_FOG == 1)
        visible = 1
    else
        visible = 0
}

/*
with (Baddy)
{
    if (DRAW_FOG == 1)
        visible = 1
    else
        visible = 0
}
*/

/* 
** Now we want to remove the black and gray fog surrounding any of the
** instances of obj_revealer_parent and their child objects. In 
** obj_revealer_parent exists a variable called VISION_RADIUS. This is
** used to determine what to remove from the surface. This is done by
** drawing a white circle centered at the instance of radius 
** VISION_RADIUS. Invisible units whose vision is shown become 
** visible. Also, all nearby invisible enemy units are revealed
** if they are within another units' radius whose vision is shown.
*/
draw_set_color(c_white)

//with (obj_revealer_parent)
with (Friendly)
{
    if (SHOW_VISION)
    {
        visible = 1
        var cx, cy, dx, dy, dd; //See NOTE 1
        cx = x div other.SIZE_W + 1
        cy = y div other.SIZE_H + 1
        dx = VISION_RADIUS div other.SIZE_W + 2
        dy = VISION_RADIUS div other.SIZE_H + 2
        var i, j, surface;
        for (i=-dx; i&lt;=dx; i+=1)
        for (j=-dy; j&lt;=dy; j+=1)
        {
            var xx, yy;
            xx = min(max(cx + i, 0), other.FOG_GRID_WIDTH)
            yy = min(max(cy + j, 0), other.FOG_GRID_HEIGHT)
            
            surface = ds_grid_get(other.FOG_GRID_BLACK, xx, yy)
            surface_set_target(surface)
            draw_circle(x - xx * other.SIZE_W, y - yy * other.SIZE_H, VISION_RADIUS, 0)
            
            surface = ds_grid_get(other.FOG_GRID_GRAY, xx, yy)
            surface_set_target(surface)
            draw_circle(x - xx * other.SIZE_W, y - yy * other.SIZE_H, VISION_RADIUS, 0)
        }
       //with (obj_revealer_parent)
        with (Friendly)
        {
            if (visible == 0 &amp;&amp; distance_to_object(other) &lt;= other.VISION_RADIUS)
                visible = 1
        }
    }
}

        //with (obj_revealer_parent)
        with (Baddy)
        {
            //if Baddy is invisible AND distance to the nearest friendly object is less than its vision radius
            if (visible == 0 &amp;&amp; distance_to(instance_nearest(x, y, Friendly)) &lt;= (instance_nearest(x, y, Friendly)).VISION_RADIUS)
            {
                visible = 1
            }
            else if (DRAW_FOG == 0 &amp;&amp; distance_to(instance_nearest(x, y, Friendly)) &gt; (instance_nearest(x, y, Friendly)).VISION_RADIUS)
            {
                visible = 0 
            }
        }
        
        with (Game_Object)
        {
            //if Baddy is invisible AND distance to the nearest friendly object is less than its vision radius
            if (Selectable == 2 &amp;&amp; distance_to(instance_nearest(x, y, Friendly)) &lt;= (instance_nearest(x, y, Friendly)).VISION_RADIUS)
            {
                Selectable = 0
            }
            else if ( distance_to(instance_nearest(x, y, Friendly)) &gt; (instance_nearest(x, y, Friendly)).VISION_RADIUS)
            {
                Selectable = 2 
            }
        }

surface_reset_target()

/* NOTE 1
** The purpose of these variables are to limit the cells in the grid to check. 
** The center cell to check is cx, cy. dx and dy refer to the total number of
** cells in their respective directions to check when updating the fog.
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_blend_mode_ext(bm_inv_src_alpha, bm_src_color)
var i, j;

for (j=0; j&lt;FOG_GRID_HEIGHT; j+=1)
for (i=0; i&lt;FOG_GRID_WIDTH; i+=1)
{
    draw_surface(ds_grid_get(FOG_GRID_GRAY, i, j), SIZE_W * i, SIZE_H * j)
    draw_surface(ds_grid_get(FOG_GRID_BLACK, i, j), SIZE_W * i, SIZE_H * j)
    
    
}
draw_set_blend_mode(bm_normal)
draw_set_color(c_lime)
//draw_text(32, 32, fps)


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="45">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//repeat(100)  instance_create(random(room_width), random(room_height), choose(obj_unit, obj_building, obj_enemy_unit, obj_enemy_building)) 
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
