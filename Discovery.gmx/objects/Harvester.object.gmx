<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_Harvester_down</spriteName>
  <solid>-1</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>Unit</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Destination_x = x;
Destination_y = y;

//determine unit type
Type = 1;
Level = Controller.CurrentLevel[Type];


Selectable = 0;
State = 0;

Description = "Harvester Unit.";

Health = Info.unithealth[Type, Level];
Attack = Info.attack[Type, Level];
Speed = Info.unitspeed[Type, Level];
Value = 0;
ValueType = 0;

Collision = 0;

VISION_RADIUS = Info.Range[2]; //Used in obj_fog_controller to remove the fog
DRAW_FOG = 0 //if true (1), then this object will be drawn beneath the gray fog.
SHOW_VISION = 1 //if false, then the fog around the object will not be removed.

Target = (-1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//sprite resolution

//if stationary
if( State == 0 )
{
    //use down
    sprite_index = spr_Harvester_down;
    //no rotation
    image_speed = 0;
}   
else
{
    //determine direction
    
    //if down
    if( direction &lt; 292.5  &amp;&amp; direction &gt; 247.5 )
    {
        //use down
        sprite_index = spr_Harvester_down;
    }
    //if downleft
    else if( direction &lt; 247.5 &amp;&amp; direction &gt; 202.5 )
    {
        //use up
        sprite_index = spr_Harvester_downleft;
    }
    //if left
    else if( direction &lt; 202.5 &amp;&amp; direction &gt; 157.5 )
    {
        //use up
        sprite_index = spr_Harvester_left;
    }
    //if upleft
    else if( direction &lt; 157.5 &amp;&amp; direction &gt; 112.5 )
    {
        //use up
        sprite_index = spr_Harvester_upleft;
    }
    //if up
    else if( direction &lt; 112.5 &amp;&amp; direction &gt; 67.5 )
    {
        //use up
        sprite_index = spr_Harvester_up;
    }
    //if upright
    else if( direction &lt; 67.5 &amp;&amp; direction &gt; 22.5 )
    {
        //use up
        sprite_index = spr_Harvester_upright;
    }
    //if right
//problem case
    else if( direction &lt; 22.5 || direction &gt; 337.5 )
    {
        //use up
        sprite_index = spr_Harvester_right;
    }
    //if downright
    else if( direction &lt; 337.5 &amp;&amp; direction &gt; 292.5 )
    {
        //use up
        sprite_index = spr_Harvester_downright;
    }
    
    //use image rotation
    image_speed = .25;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if time to upgrade
if( Controller.Upgrade == Type &amp;&amp; Level &lt; Controller.CurrentLevel[Type] )
{
    //Update stats
    Level = Controller.CurrentLevel[Type];     
    Attack = Info.attack[Type, Level];
    Speed = Info.unitspeed[Type, Level];
    
    //Health increases by the difference in level and previous level    
    Health = Health + (Info.unithealth[Type, Level] - Info.unithealth[Type, (Level - 1) ]  );
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Selection Control



//double click selection AND Selected type matches this unit
if( (Controller.DoubleClick == (-1)) &amp;&amp; ((Controller.Selected).Type == Type) )
{
    //if x is in view AND y is in view
    if( (x &gt; view_xview[0] &amp;&amp; x &lt; (view_xview[0]+view_wview[0]) ) &amp;&amp; (y &gt; view_yview[0] &amp;&amp; y &lt; (view_yview[0]+view_hview[0]) ) )
    {
        //test destroy
        //instance_destroy();
        
        Selectable = 1;
        //sprite_index = selected;
        image_alpha = .5;
        Controller.Selected = id;
        instance_create(x, y, Frame);        
    }
}


//drag selection
if( Controller.hold == 2 )
{

//if dragged area is greater than 8 x 8, then use drag selection
if( ((mouse_x - mousx) &gt; 8 || (mouse_x - mousx) &lt; -8) &amp;&amp; ((mouse_y - mousy) &gt; 8 || (mouse_y - mousy) &lt; -8) )
{


    //from the left
    if( x &gt; Controller.mousx &amp;&amp; x &lt; mouse_x )
    {
        //from the top-left
        if( y &gt; Controller.mousy &amp;&amp; y &lt; mouse_y )
        {
            //toggle selected state
            if( Selectable == 1 )
            {
                //Selectable = 0;
                //image_alpha = 1;
                //Controller.Selected = 0;

            }
            else
            {
                Selectable = 1;
                //sprite_index = selected;
                image_alpha = .5;
                Controller.Selected = id;
                instance_create(x, y, Frame);
                
                
            }
        }
        //bottom
        else if( y &lt; Controller.mousy &amp;&amp; y &gt; mouse_y )
        {
            //toggle selected state
            if( Selectable == 1 )
            {
                //Selectable = 0;
                //image_alpha = 1;
                //Controller.Selected = 0;
            }
            else
            {
                Selectable = 1;
                //sprite_index = selected;
                image_alpha = .5;
                Controller.Selected = id;
                instance_create(x, y, Frame);
            }
        }
        else
        {
            Selectable = 0;
            image_alpha = 1;
            Controller.Selected = 0;
        }
    }
    //right
    else if( x &lt; Controller.mousx &amp;&amp; x &gt; mouse_x )
    {
        //top
        if( y &gt; Controller.mousy &amp;&amp; y &lt; mouse_y )
        {
            //toggle selected state
            if( Selectable == 1 )
            {
                //Selectable = 0;
                //image_alpha = 1;
                //Controller.Selected = 0;
            }
            else
            {
                Selectable = 1;
                //sprite_index = selected;
                image_alpha = .5;
                Controller.Selected = id;
                instance_create(x, y, Frame);
            }
        }
        //bottom
        else if( y &lt; Controller.mousy &amp;&amp; y &gt; mouse_y )
        {
            //toggle selected state
            if( Selectable == 1 )
            {
                //Selectable = 0;
                //image_alpha = 1;
                //Controller.Selected = 0;
            }
            else
            {
                Selectable = 1;
                //sprite_index = selected;
                image_alpha = .5;
                Controller.Selected = id;
                instance_create(x, y, Frame);
            }
        }
        else
        {
            Selectable = 0;
            image_alpha = 1;
            Controller.Selected = 0;
        }
    }
    else
    {
        Selectable = 0;
        image_alpha = 1;
        Controller.Selected = 0;
    }   
} 

}


if( Controller.Selected == 0 )
{
    //if selected
    if( Selectable == 1 )
    {
        Controller.Selected = id;
    }   
}



</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if put in a "Pre-Built" State
if( State == 9 )
{
    if( place_meeting(x, y, Friendly) == true || (distance_to(Collision) &lt; 2 &amp;&amp; Collision != 0)  || (place_meeting(x, y, Resource) == true &amp;&amp; Value == Info.value[Type, Controller.CurrentLevel[Type]]) )
    {
        //if solid
        if( solid == 1)
        {
            solid = 0;
        }
        
        //move_away(Collision, Speed);
    
        //Set Destination to distance betwen objects on the opposite side

        //object is at same spot
        if( (x == (Collision).x) &amp;&amp; (y == (Collision).y) )
        {
            //direction = random(1) * 360;
            x = x + random(8);
            //speed = Speed;
        }
        else
        {
            //if vertically aligned
            if( x == (Collision).x )
            {
                //if directly above target
                if( y &lt; (Collision).y)
                {
                    //move up
                    move_towards_point(x, y-((Collision).y-y), Speed);
                }
                //if directly below target
                else if( y &gt; (Collision.y) )
                {
                    //move down
                    move_towards_point(x, y+(y-(Collision).y), Speed);
                }
                    
            }
            else if( y == (Collision).y )
            {
                //if directly right of target
                if( x &gt; (Collision).x)
                {
                    //move right
                    move_towards_point(x+(x-(Collision).x), y, Speed);
                }            
                //if directly left of target
                else if( x &lt; (Collision).x)
                {
                    //move left
                    move_towards_point(x-((Collision).x-x), y, Speed);
                }
            }
            //if right and below
            else if( x &gt; (Collision).x &amp;&amp; y &gt; (Collision).y )
            {
                move_towards_point(x+(x-(Collision).x), y+(y-(Collision).y), Speed);
            }
            //if right and above
            else if( x &gt; (Collision).x &amp;&amp; y &lt; (Collision).y )
            {
                move_towards_point(x+(x-(Collision).x), y-((Collision).y-y), Speed);
            }
            //if left and below
            else if( x &lt; (Collision).x &amp;&amp; y &gt; (Collision).y )
            {
                move_towards_point(x-((Collision).x-x), y+(y-(Collision).y), Speed);
            }
            //if left and above
            else if( x &lt; (Collision).x &amp;&amp; y &lt; (Collision).y )
            {
                move_towards_point(x-((Collision).x-x), y-((Collision).y-y), Speed);
            }
        
        
        
              
        }
        
        //instance_destroy();
        //move_towards_point(Destination_x, Destination_y, Speed);
               
        
    }
    else
    {
        //instance_destroy();
        solid = 1;
        State = 1;
        motion_set(0, 0);
        
        //Destination_x = x;
        //Destination_y = y;
        
        Collision = 0;
    }
    
}
else
{

    //Command destination resolution
        //if Unit is selected AND Command is being issued AND new destination is being set
    if( Selectable == 1 &amp;&amp; Controller.Command == 1 &amp;&amp; Controller.Destination_x != (-1) &amp;&amp; Controller.Destination_y != (-1) )
    {
        //pass destination to unit
        Destination_x = Controller.Destination_x;
        Destination_y = Controller.Destination_y;
        
        //if command is harvest or move
        if( Controller.Option == 11 || Controller.Option == 0)
        {
            //if there is a Resource close enough to destination at time of designation
                //requires a distance from point
            if( distance_from( Destination_x, Destination_y, instance_nearest(Destination_x, Destination_y, Resource))  &lt;= Info.Range[0] )
            {
                //target nearest resource to destination
                Target = instance_nearest(Destination_x, Destination_y, Resource);
                
                //Ensure Target is of same value type as harvester OR carried resources equals 0
                
                //if the Target's value type is NOT equal to the harvester's
                    //AND valuetype != 0
                if( (Target).Valuetype != Valuetype  &amp;&amp; Valuetype != 0)
                {
                    //nullify target
                    Target = (-1);   
                }
                //if not
                    //if there is no resources already being carried
                else if( Value == 0 )
                {
                    ValueType = (Target).Type;
                }
            }
            else
            {
                Target = (-1);
                //if there is no resorces being carried
                if( Value == 0 )
                {
                    ValueType = 0;
                }
            }
            
            //Change state to moving
            State = 1;
        }
    }
    

    //State Based resolution    
        //if State equals 0
    if( State == 0 )
    {
        //Get Harvester moving back to its Resource
            //if it has a Resource to go to
            //AND is not dealing with a Collision
            //AND is NOT full
        if( Target != (-1) &amp;&amp; Collision == 0 &amp;&amp; Value != Info.value[Type, Level])
        {
            //Change state to moving
            State = 1;
            //set destination to resource
            Destination_x = (Target).x;
            Destination_y = (Target).y;
        }
        //if Harvester is full AND "Ready"
        else if( Value == Info.value[Type, Level] )
        {
            //Change state to moving
            State = 1;
        
            //set destination to the NEAREST HQ
            Destination_x = (instance_nearest(x, y, HQ_Building)).x  
            Destination_y = (instance_nearest(x, y, HQ_Building)).y
        }
    
        

    
    }    
           
    //if State equals 1
    if( State == 1 )
    {
        //if not at destination (or within one jump)
        if( ((x &lt; Destination_x-(Speed-(Speed/10))) || (x &gt; Destination_x + (Speed/10))) || ((y &lt; Destination_y - (Speed/10)) || (y &gt; Destination_y + (Speed/10))) &amp;&amp; (Destination_x != 0 &amp;&amp; Destination_y != 0) )
        //if( ((x &lt; Destination_x-(Speed-1)) || (x &gt; Destination_x + (Speed-1))) || ((y &lt; Destination_y - (Speed-1)) || (y &gt; Destination_y + (Speed-1))) &amp;&amp; (Destination_x != 0 &amp;&amp; Destination_y != 0) )
        {
            //State = 1;
            //good method to move unit
            //if( distance_to_object(Resource) &lt; 2 || ( (distance_to_object(HQ_Building) &lt; 2) &amp;&amp; (Value == Info.value[Type, Controller.CurrentLevel[Type]]) ) )
            //if Harvester is within 2 pixels of its target OR full AND returning to HQ Building
            if( ( (Target != (-1)) &amp;&amp; (distance_to(Target) &lt; 2 )) || ( (distance_to_object(HQ_Building) &lt; 2) &amp;&amp; (Value &gt; 0) ) )
            {
                //instance_destroy();
                move_towards_point(Destination_x, Destination_y, Speed);
            }
            //else
            {
                mp_potential_step(Destination_x, Destination_y, Speed, false);
            }
    
        }
        else //if(State == 1)//if( x == Destination_x &amp;&amp; y == Destination_y )
        {
            State = 0;
            motion_set(0, 0);
    
            Destination_x = x;
            Destination_y = y;
    
            //image_alpha = 1;
            //Selectable = 0;
        }
        
        if( /*(State == 0 || State == 1) &amp;&amp;*/  Target != (-1) &amp;&amp; ((Target).Target == id) &amp;&amp; (collision_with((Target)) == true) )
        {
            //change state to "harvesting"
            State = 3;
        }
        
        //if Harvester is removed from Resource AND NOT full
        //if( distance_to((Target)) &gt; Info.Range[0] &amp;&amp; (Value != Info.value[Type, Level]) )
        //{
            //Change state to moving
            //State = 1;
            //(Target).Target = (-1);
            //Target = (-1);
        //}
    }
          
    //if State equals 3
    if( State == 3 )
    {
        //if the Resource's current value - harvester's attack (/room_speed for "per step") is MORE THAN OR EQUAL TO 0
            //AND if the harvester's value + harvester's attack (/room_speed for "per step") is LESS THAN OR EQUAL TO harvester's maxValue
        if( ((Target).Value - (Attack)/room_speed &gt;= 0 ) &amp;&amp; (Value + (Attack)/room_speed &lt;= Info.value[ Type, Level ] ) )
        {
            //decrement Resource's value
            (Target).Value = (Target).Value - (Attack/room_speed);
            //increment Harvester's value
            Value = Value + (Attack/room_speed);
        }
        //if decrement would excede Resource's available value
        else if( ((Target).Value - (Info.attack[ Type, Controller.CurrentLevel[Type] ])/room_speed &lt; 0 ) )
        {
            //increment Harvester's value with remains
            Value = Value + (Target).Value;
            //decrement Resource's value to 0
            (Target).Value = 0;
            
            //remove id from Resource's Target
            (Target).Target = (-1);
        
            //if target resource is a Woods object   
            if( (Target).Type == 16 )
            {
                //"kill" resource
                //State = 8;   
                with( Woods )
                {
                    if( id == other.Target )
                    {
                        instance_destroy();   
                    }
                }
            
            }
        }
        //if resource's current value + harvester's attack (/room_speed) is MORE THAN maxValue
            //(increment would excede Harvester's maximum carry
        else if( ((Target).Value + (Info.attack[ Type, Level ])/room_speed &gt;= Info.value[ Type, Level ] ) )
        {
            //decrement Resource's value
                //only decrement the difference between current load and maximum load
            (Target).Value = (Target).Value - ((Info.value[ Type, Level ]) - Value );

            //increment Harvester's value to maximum available value
            Value = Info.value[ Type, Level ];
        
            //remove this Harvester from the Harvested resource's Target
                //set Target's Target to 0
            (Target).Target = (-1);
            
            //Get Moving
            State = 1;
            
            //set destination to the NEAREST HQ
            Destination_x = (instance_nearest(x, y, HQ_Building)).x  
            Destination_y = (instance_nearest(x, y, HQ_Building)).y
            
        }
        //if Harvester is full
        else if( Value == Info.value[ Type, Level ] )
        {
            //remove this Harvester from the Harvested resource's Target
                //set Target's Target to 0
            (Target).Target = (-1);
            
            //Change state to moving
            State = 1;
            
            //set destination to the NEAREST HQ
            Destination_x = (instance_nearest(x, y, HQ_Building)).x  
            Destination_y = (instance_nearest(x, y, HQ_Building)).y
        }
    }
    
 




}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Destruction Resolution


if( State == 8 || Health == 0 )
{
    //remove this Harvester as Resource's target so that other harvesters may harvest the resource.
    if( (Target).Target == id )
    {
        (Target).Target = (-1);
    }

    instance_destroy();
}


//if resource is destroyed
if( ((Target).x == 0) &amp;&amp; ((Target).y == 0) &amp;&amp; (Target != (-1)) )
{
    Target = (-1);
    //Destination_x = x;
    //Destination_y = y;
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="Resource">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if Harvester is ready OR Moving
if( State == 0 || State == 1 )
{

        //ensure resource's id is being recorded
    if( (other).Type &gt;= 16 &amp;&amp; (other).Type &lt;= 18 )
    {

        //if resource is "Ready" &amp;&amp; Harvester has room
        if( (other.id).State == 0 &amp;&amp; Value &lt; Info.value[Type, Level] )
        {
            //if Harvester has like resource or is empty
                //AND Resource's Target matches Harvester id or is -1
            if( (ValueType == (other).Type || Value == 0) &amp;&amp; ((other).Target == id || (other).Target == (-1)) )
            {
                //instance_destroy();
                //Target = other.id;
                ValueType = other.Type;
                //change state to "Harvesting"
                State = 3;
    
                //Destination_x = (Target).x;
                //Destination_y = (Target).y;
                
                (other).Target = id;
                
            }
        }
        else if( Value == Info.value[Type, Level] )
        {
            Collision = (other).id;
            State = 9;
        }
    
    }
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="HQ_Building">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if HQ_Building is NOT "Under Construction", "Dying", AND "Pre-Built"
if( (other).state != 6 &amp;&amp; (other).state != 8 &amp;&amp; (other).state != 9)
{
    //if Harvester has a load
    if( Value &gt; 0 )
    {
    
        //dump resources
            //if wood
        if( ValueType == 16 )
        {
            //deposit wood
            Controller.masterWood = Controller.masterWood + Value;
            //remove value
            Value = 0;
            //remove value type
            ValueType = 0;
        }
        else if( ValueType == 17 )
        {
            //deposit ore
            Controller.masterOre = Controller.masterOre + Value;
            //remove value
            Value = 0;
            //remove value type
            ValueType = 0;
        }
        else if( ValueType == 18 )
        {
            //deposit wood
            Controller.masterEssence = Controller.masterEssence + Value;
            //remove value
            Value = 0;
            //remove value type
            ValueType = 0;
        }

        //if targeting a resource    
        if( Target != (-1) )
        {
            //set destination to return to it
            Destination_x = (Target).x;
            Destination_y = (Target).y;
            //ValueType = (Target).Type;
            
            State = 1;
            
            //resolve destroyed target
            if( ((Target).x == 0) &amp;&amp; ((Target).y == 0)  )
            {
                Target = (-1);
                Destination_x = x;
                Destination_y = y;
                
                State = 0;
            }
            
            
    
        }
        else
        {
            Destination_x = x;
            Destination_y = y;
            
            State = 0;
        }
    
    
    }
    else
    {
        State = 9;
        Collision = other.id;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
