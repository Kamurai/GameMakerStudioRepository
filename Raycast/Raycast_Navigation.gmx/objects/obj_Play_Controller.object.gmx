<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-100</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Display Bounds
DisplayUpperBound = room_height - 160;
DisplayLowerBound = room_height;
DisplayWestBound = 0;
DisplayEastBound = room_width;

    //1 Buttons Bounds
    ButtonsUpperBound = DisplayUpperBound;
    ButtonsLowerBound = DisplayLowerBound;
    ButtonsWestBound = DisplayWestBound + 10;
    ButtonsEastBound = ButtonsWestBound + 120;
    
        //1 Clear Button
        ClearUpperBound = ButtonsUpperBound + 36;
        ClearLowerBound = ClearUpperBound + 36;
        ClearWestBound = ButtonsWestBound + 10;
        ClearEastBound = ButtonsEastBound - 10;
        //3 Options
        OptionsLowerBound = ButtonsLowerBound - 12;
        OptionsUpperBound = OptionsLowerBound - 36;
        OptionsWestBound = ButtonsWestBound + 10;
        OptionsEastBound = ButtonsEastBound - 10;
        //2 Level Select
        LevelSelectUpperBound = ClearLowerBound;
        LevelSelectLowerBound = OptionsUpperBound;
        LevelSelectWestBound = ButtonsWestBound + 10;
        LevelSelectEastBound = ButtonsEastBound - 10;
    
    //3 Info Bounds
    InfoUpperBound = DisplayUpperBound + 36;
    InfoLowerBound = room_height - 12;
    InfoEastBound = DisplayEastBound - 10;
    InfoWestBound = InfoEastBound - 120;
    
        //RotateLeft
        RotateLeftUpperBound = InfoUpperBound + 4;
        RotateLeftLowerBound = RotateLeftUpperBound + 32;
        RotateLeftWestBound = InfoWestBound + 4;
        RotateLeftEastBound = RotateLeftWestBound + 56;
        //RotateRight
        RotateRightUpperBound = InfoUpperBound + 4;
        RotateRightLowerBound = RotateRightUpperBound + 32;
        RotateRightWestBound = RotateLeftEastBound;
        RotateRightEastBound = InfoEastBound - 4;
        //Par
        ParUpperBound = RotateLeftLowerBound;
        ParLowerBound = InfoLowerBound - 4;
        ParWestBound = InfoWestBound + 4;
        ParEastBound = InfoEastBound - 4;
            //ParLeft
            ParLeftUpperBound = ParUpperBound + 4;
            ParLeftLowerBound = ParLowerBound - 4;
            ParLeftWestBound = ParWestBound + 4;
            ParLeftEastBound  = ParWestBound + 56;  
            //ParRight
            ParRightUpperBound = ParUpperBound + 4;
            ParRightLowerBound = ParLowerBound - 4;
            ParRightWestBound = ParLeftEastBound;
            ParRightEastBound = ParEastBound - 4;  
    
    //2 Title Bounds
    TitleUpperBound = DisplayUpperBound;
    TitleLowerBound = DisplayUpperBound + 32;
    
    TitleWestBound = ButtonsEastBound + (InfoWestBound - ButtonsEastBound)/3 + 12;
    TitleEastBound = InfoWestBound - (InfoWestBound - ButtonsEastBound)/3 - 12;

    //2 Ingredients Bounds
    IngredientsUpperBound = TitleLowerBound;
    IngredientsLowerBound = DisplayLowerBound;
    
    IngredientsWestBound = ButtonsEastBound + 12;
    IngredientsEastBound = InfoWestBound - 12;

    
//Width: 2048
//Height: 325
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>image_speed = 0;

Emitting = false;
Searching = false;

EmitTracker = 0;
EmitCount = 0;
//EmitArrayX[0] = 0; //obj_Emitter.x;
//EmitArrayY[0] = 0; //obj_Emitter.y;

//EmitAngle = 90; //obj_Emitter.image_angle
ImageAngle = 0;

//i = 0; //obj_Emitter.x;
//j = 0; //obj_Emitter.y;

AdjustX = 0;
AdjustY = 0;

MirrorCount = 0;

//EmitAngleArray[0] = 90;

CurrentContactObject = 0;

Targeting = false;
Winning = false;

AngleDiff = 0;
Turning = false;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//obj_Navigation.ReturnToRoom = room_get_name(room);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(Winning)
{
    //do something
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="57">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(!Targeting &amp;&amp; !Emitting &amp;&amp; !(position_meeting(mouse_x, mouse_y, obj_GameObject)) )
{
    instance_create(mouse_x,mouse_y,obj_Mirror_2Sided_Rep);
    Targeting = true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(Emitting)
{
    //draw beam path based on returned array:
    //walk through emit array based on emit count
    for(tracker = 0; tracker &lt; (EmitCount); tracker++)
    {
        draw_line(EmitArrayX[tracker], EmitArrayY[tracker],EmitArrayX[tracker+1],EmitArrayY[tracker+1]);
    }    
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
//Display Bounds
draw_set_color(c_gray);
draw_rectangle(DisplayWestBound, DisplayUpperBound, DisplayEastBound, DisplayLowerBound, false);

    //Buttons Bounds
    draw_set_color(c_lime);
    draw_rectangle(ButtonsWestBound, ButtonsUpperBound, ButtonsEastBound, ButtonsLowerBound, false);

        //Clear Button
        draw_set_color(c_red);
        draw_rectangle(ClearWestBound, ClearUpperBound, ClearEastBound, ClearLowerBound, false);

        //Level Select
        draw_set_color(c_yellow);
        draw_rectangle(LevelSelectWestBound, LevelSelectUpperBound, LevelSelectEastBound, LevelSelectLowerBound, false);

        //Options
        draw_set_color(c_green);
        draw_rectangle(OptionsWestBound, OptionsUpperBound, OptionsEastBound, OptionsLowerBound, false);

    //Info Bounds
    draw_set_color(c_navy);
    draw_rectangle(InfoWestBound, InfoUpperBound, InfoEastBound, InfoLowerBound, false);
   
    
        //RotateLeft
        draw_set_color(c_olive);
        draw_rectangle(RotateLeftWestBound, RotateLeftUpperBound, RotateLeftEastBound, RotateLeftLowerBound, false);

        //RotateRight
        draw_set_color(c_fuchsia);
        draw_rectangle(RotateRightWestBound, RotateRightUpperBound, RotateRightEastBound, RotateRightLowerBound, false);

        //Par
        draw_set_color(c_white);
        draw_rectangle(ParWestBound, ParUpperBound, ParEastBound, ParLowerBound, false);
 
            //ParLeft
            draw_set_color(c_green);
            draw_rectangle(ParLeftWestBound, ParLeftUpperBound, ParLeftEastBound, ParLeftLowerBound, false);

            //ParRight
            draw_set_color(c_yellow);
            draw_rectangle(ParRightWestBound, ParRightUpperBound, ParRightEastBound, ParRightLowerBound, false);
            
    //Title Bounds
    draw_set_color(c_purple);
    draw_rectangle(TitleWestBound, TitleUpperBound, TitleEastBound, TitleLowerBound, false);
     
    //Ingredients Bounds
    draw_set_color(c_maroon);
    draw_rectangle(IngredientsWestBound, IngredientsUpperBound, IngredientsEastBound, IngredientsLowerBound, false);

//Width: 2048
//Height: 325
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(!Targeting)
{

    if(Emitting == true)
    {
        Emitting = false;
    }
    else
    {
        //EmitAngle is set at this point (at least by the emitter)
        EmitAngleInRadians = ((EmitAngle*pi)/180);
    
        //determine beam path:
        EmitArrayX[0] = obj_Emitter.x;
        EmitArrayY[0] = obj_Emitter.y;
        
        EmitTracker = 1;
        EmitCount = 0;
        
        i = obj_Emitter.x;
        j = obj_Emitter.y;
        
        CurrentContactObject = obj_Emitter.id;
        
        while(!Emitting)
        {
            //determine angle/emit direction
            if(EmitAngle == 0)
            {
                AdjustX = 1;
                AdjustY = 0;
            }
            else if(EmitAngle == 90)
            {
                AdjustX = 0;
                AdjustY = -1;
            }
            else if(EmitAngle == 180)
            {
                AdjustX = -1;
                AdjustY = 0;
            }
            else if(EmitAngle == 270)
            {
                AdjustX = 0;
                AdjustY = 1;    
            }
            else if(EmitAngle == 360)
            {
                AdjustX = 1;
                AdjustY = 0;    
            }
            else if((EmitAngle &gt; 0) &amp;&amp; (EmitAngle &lt; 90)) //quadrant 1
            {
                AdjustX = cos(EmitAngleInRadians);
                AdjustY = sin(EmitAngleInRadians) * (-1);
            }
            else if((EmitAngle &gt; 90) &amp;&amp; (EmitAngle &lt; 180)) //quadrant 2
            {
                AdjustX = cos(EmitAngleInRadians);
                AdjustY = sin(EmitAngleInRadians) * (-1);
            }
            else if((EmitAngle &gt; 180) &amp;&amp; (EmitAngle &lt; 270)) //quadrant 3
            {
                AdjustX = cos(EmitAngleInRadians);
                AdjustY = sin(EmitAngleInRadians) * (-1);
            }
            else if((EmitAngle &gt; 270) &amp;&amp; (EmitAngle &lt; 360)) //quadrant 4
            {
                AdjustX = cos(EmitAngleInRadians);
                AdjustY = sin(EmitAngleInRadians) * (-1);
            }
            
            Searching = true;
            //loop through coordinates on line based on angle
            while(Searching)
            {
                i= i + AdjustX;
                j= j + AdjustY;
                
                //if GameObject is found
                if((position_meeting(i,j,obj_GameObject)) &amp;&amp; (instance_position(i,j,obj_GameObject).id != CurrentContactObject))
                {
                    CurrentContactObject = (instance_position(i,j,obj_GameObject));
                /*
                    //if GameObject is Emitter and no beams have been drawn yet
                    if(object_get_name(instance_position(i,j,obj_GameObject).object_index) == "obj_Emitter" &amp;&amp; EmitCount == 0)
                    {
                        //continue;
                    }
                    else 
                */    
                    
                    //if GameObject is Opaque
                    if(position_meeting(i,j,obj_Opaque))
                    {
                        //then assign coordinates
                        EmitArrayX[EmitTracker] = i;
                        EmitArrayY[EmitTracker] = j;
                        EmitTracker++;
                        EmitCount++;
                        
                        //end searching
                        Searching = false;
                        Emitting = true;
                        
                    }
                    //if GameObject is Reflective
                    else if(position_meeting(i,j,obj_Reflective))
                    {
                        //then assign coordinates
                        EmitArrayX[EmitTracker] = i;
                        EmitArrayY[EmitTracker] = j;
                        EmitTracker++;
                        EmitCount++;
                        
                        ImageAngle = (instance_position(i,j,obj_Reflective).image_angle);
                        
                        
                        //handle reflection:
                        //determine from which object the light is reflecting
                        //if 2 sided mirror
                        if(object_get_name(instance_position(i,j,obj_Reflective).object_index) == "obj_Mirror_2Sided_Rep" || object_get_name(instance_position(i,j,obj_Reflective).object_index) == "obj_Mirror_1Sided_Rep")
                        {
                            AngleDiff = (EmitAngle - ImageAngle);
                            //instance_destroy();
                        
                            while((AngleDiff &lt; 0) || (AngleDiff &gt; 359))
                            {
                            
                                if(AngleDiff &gt; 360)
                                {
                                    AngleDiff = AngleDiff - 360;
                                }
                                else if(AngleDiff &lt; 0)
                                {
                                    AngleDiff = AngleDiff + 360;
                                }
                            }
                            
                            //if difference is 0
                            if(AngleDiff == 0)
                            {
                                //end as if opaque (hits the side)
                                Emitting = true;
                            }
                            //if difference is 180
                            else if(AngleDiff == 180)
                            {
                                //end as if opaque (hits the side)
                                Emitting = true;
                            }
                            //if difference is 360
                            else if(AngleDiff == 360)
                            {
                                //end as if opaque (hits the side)
                                Emitting = true;
                            }
                            //if difference is 90
                            else if(AngleDiff == 90)
                            {
                                //end as if opaque (reflects back on itself)
                                Emitting = true;
                            }
                            //if difference is 270
                            else if(AngleDiff == 270)
                            {
                                //end as if opaque (reflects back on itself)
                                Emitting = true;
                            }
                            //if difference is from 1 to 89 //quadrant 1
                            else if( (AngleDiff &gt; 0) &amp;&amp; (AngleDiff &lt; 90) )
                            {
                                //if reflecting vertically (quadrant 1 to quandrant 4)
                                EmitAngle = ImageAngle - (EmitAngle - 180) + (ImageAngle - 180);
                                EmitAngleInRadians = ((EmitAngle*pi)/180);
                                //instance_destroy();
                        //Emitting = true;
                        
                                //from [45,0] to [315,0]
                                    //C = B - (A - 180) + D = B - (A - 180) + (B - 180) = 0 - (45 - 180) + (0 - 180) = 0 - (-135) + (-180) = 0 + (135) - (180) = -45 = 315 //from quadrant 1 to 4
                                
                                //from [90,45] to [0,45]
                                    //C = B - (A - 180) + D = B - (A - 180) + (B - 180) = 45 - (90 - 180) + (45 - 180) = 45 - (-90) + (-135) = 45 + (90) - (135) = 135 - 135 = 0  //from quadrant 1 to 4
                            
                                //from [89,0] to [271,0]
                                    //C = B - (A - 180) + D = B - (A - 180) + (B - 180) = 0 - (89 - 180) + (0 - 180) = 0 - (-91) + (-180) = 0 + (91) - (180) = -89 = 271 //from quadrant 1 to 4
                                
                                //from [90,1] to [272,1]
                                    //C = B - (A - 180) + D = B - (A - 180) + (B - 180) = 1 - (90 - 180) + (1 - 180) = 1 - (-90) + (-179) = 1 + (90) - (179) = -88 = 272 //from quadrant 1 to 4
                                
                                
                                //from [1,0] to [359,0]
                                    //C = B - (A - 180) + D = B - (A - 180) + (B - 180) = 0 - (1 - 180) + (0 - 180) = 0 - (-179) + (-180) = 0 + (179) - (180) = -1 = 359 //from quadrant 1 to 4
                                    
                                //from [90,89] to [88,89]
                                    //C = B - (A - 180) + D = B - (A - 180) + (B - 180) = 89 - (90 - 180) + (89 - 180) = 89 - (-90) + (-91) = 89 + (90) - (91) = 88 //from quadrant 1 to 4
                                    
                                //if reflecting horizontally (quadrant 1 to quadrant 2)
                                    //180 - (EmitAngle - (instance_position(i,j,obj_Reflective).image_angle))
                                
                                //this should never happen:
                                    //in cases where the beam strikes the side of the mirror, the object should act as if opaque
                            }
                            //if difference is from 91 to 179 //quadrant 2
                            else if( (AngleDiff &gt; 90) &amp;&amp; (AngleDiff &lt; 180) )
                            {
                                //if reflecting vertically (quadrant 2 to quandrant 3)
                                EmitAngle = ImageAngle - (EmitAngle - 180) + (ImageAngle - 180);
                                EmitAngleInRadians = ((EmitAngle*pi)/180);
                                
                                //from [135,0] to [225,0]
                                    //C = B - (A - 180) + D = B - (A - 180) + (B - 180) = 0 - (135 - 180) + (0 - 180) = 0 - (-45) + (-180) = 0 + (45) - (180) = -135 = 225 //from quadrant 2 to 3
                                
                                //from [90,315] to [180,315]
                                    //C = B - (A - 180) + D = B - (A - 180) + (B - 180) = 315 - (90 - 180) + (315 - 180) = 315 - (-90) + (135) = 315 + (90) + (135) = 540 = 180 //from quadrant 1 or 2 to 3 or 4
                              
                                //from [91,0] to [91,0]
                                    //C = B - (A - 180) + D = B - (A - 180) + (B - 180) = 0 - (91 - 180) + (0 - 180) = 0 - (-89) + (-180) = 0 + (89) - (180) = 91  //from quadrant 2 to 3
                                    
                                //from [90,359] to [268,359]
                                    //C = B - (A - 180) + D = B - (A - 180) + (B - 180) = 359 - (90 - 180) + (359 - 180) = 359 - (-90) + (179) = 359 + (90) + (179) = 628 = 268 //from quadrant 2 to 3
                                
                                //from [179,0] to [181,0]
                                    //C = B - (A - 180) + D = B - (A - 180) + (B - 180) = 0 - (179 - 180) + (0 - 180) = 0 - (-1) + (-180) = 0 + (1) - (180) = -179 = 181 //from quadrant 2 to 3
                                
                                //from [90,271] to [92,271]
                                    //C = B - (A - 180) + D = B - (A - 180) + (B - 180) = 271 - (90 - 180) + (271 - 180) = 271 - (-90) + (91) = 271 + (90) + (91) = 452 = 92 //from quadrant 1 or 2 to 3     
                                    
                                //if reflecting horizontally (quadrant 2 to quadrant 1)
                                    //0 + (180 - (EmitAngle - (instance_position(i,j,obj_Reflective).image_angle)))
                                
                                //this should never happen:
                                    //in cases where the beam strikes the side of the mirror, the object should act as if opaque
                                 
                            }
                            //if difference is from 181 to 269 //quadrant 3
                            else if( (AngleDiff &gt; 180) &amp;&amp; (AngleDiff &lt; 270) )
                            {
                                //if reflecting vertically (quadrant 3 to quandrant 2)
                                EmitAngle = ImageAngle - (EmitAngle - 180) + (ImageAngle - 180);
                                EmitAngleInRadians = ((EmitAngle*pi)/180);
                                
                                //from [181,0] to [179,0]
                                    //C = B - (A - 180) + D = B - (A - 180) + (B - 180) = 0 - (181 - 180) + (0 - 180) = 0 - 1 + (-180) = 0 - 1 - 180 = -181 = 179 //from quadrant 3 to 2
                                
                                //from [90,269] to [88,269]
                                    //C = B - (A - 180) + D = B - (A - 180) + (B - 180) = 269 - (90 - 180) + (269 - 180) = 269 - (-90) + 89 = 269 + 90 + 89 = 448 = 88 //from quadrant 3 to 2
                        
                                //from [269,0] to [91,0]
                                    //C = B - (A - 180) + D = B - (A - 180) + (B - 180) = 0 - (269 - 180) + (0 - 180) = 0 - (89) + (-180) = -269 = 91 //from quadrant 3 to 2
                                
                                //from [90,181] to [272,181]
                                    //C = B - (A - 180) + D = B - (A - 180) + (B - 180) = 181 - (90 - 180) + (181 - 180) = 181 - (-90) + (1) = 181 + (90) + (1) = 272 //from quadrant 3 to 2
                                
                                //from [225,0] to [,0]
                                    //C = B - (A - 180) + D = B - (A - 180) + (B - 180) = 0 - (225 - 180) + (0 - 180) = 0 - (45) + (-180) = 0 - (45) - (180) = -225 = 135 //from quadrant 3 to 2
                                
                                //from [90,225] to [,225]
                                    //C = B - (A - 180) + D = B - (A - 180) + (B - 180) = 225 - (90 - 180) + (225 - 180) = 225 - (-90) + (45) = 225 + (90) + (45) = 360 = 0 //from quadrant 3 to 2
                                
                                //if reflecting horizontally (quadrant 3 to quadrant 4)
                                    //270 + (270 - (EmitAngle - (instance_position(i,j,obj_Reflective).image_angle)))
                                
                                //this should never happen:
                                    //in cases where the beam strikes the side of the mirror, the object should act as if opaque
                                            
                            }
                            //if difference is from 271 to 359 //quadrant 4
                            else if( (AngleDiff &gt; 270) &amp;&amp; (AngleDiff &lt; 360) )
                            {
                                //if reflecting vertically (quadrant 4 to quandrant 1)
                                EmitAngle = ImageAngle - (EmitAngle - 180) + (ImageAngle - 180);
                                EmitAngleInRadians = ((EmitAngle*pi)/180);
                                
                                //from [315,0] to [45,0]
                                    //C = B - (A - 180) + D = 0 - (315 - 180) + (0 - 180) = 0 - (135) + (-180) = 0 - (135) - (180) = -315 = 45 //from quadrant 4 to 1
                                
                                //from [90,135] to [180,135]
                                    //C = B - (A - 180) + D = 135 - (90 - 180) + (135 - 180) = 135 - (90 - 180) + (135 - 180) = 135 - (-90) + (-45) = 135 + (90) - (45) = 180 //from quadrant 4 to 1
                                
                                //from [271,0] to [89,0]
                                    //C = B - (A - 180) + D = B - (A - 180) + (B - 180) = 0 - (271 - 180) + (0 - 180) = 0 - (91) + (-180) = 0 - (91) - (180) = -271 = 89  //from quadrant 4 to 1
                                    
                                //from [90,269] to [88,269]
                                    //C = B - (A - 180) + D = B - (A - 180) + (B - 180) = 269 - (90 - 180) + (269 - 180) = 269 - (-90) + (89) = 269 + (90) + (89) = 448 = 88 //from quadrant 4 to 1
                                  
                                //from [359,0] to [1,0]
                                    //C = B - (A - 180) + D = B - (A - 180) + (B - 180) = 0 - (359 - 180) + (0 - 180) = 0 - (179) + (-180) = 0 - (179) - (180) = -359 = 1 //from quadrant 4 to 1
                                
                                //from [90,181] to [272,181]
                                    //C = B - (A - 180) + D = B - (A - 180) + (B - 180) = 181 - (90 - 180) + (181 - 180) = 181 - (-90) + (1) = 181 + (90) + (1) = 272 //from quadrant 4 to 1
                                
                                //if reflecting horizontally (quadrant 4 to quadrant 3)
                                    //180 + (360 - (EmitAngle - (instance_position(i,j,obj_Reflective).image_angle)))
                                    
                                //this should never happen:
                                    //in cases where the beam strikes the side of the mirror, the object should act as if opaque
                            }
                        }
                        
                        while((EmitAngle &lt; 0) || (EmitAngle &gt; 359))
                        {
                        
                            if(EmitAngle &gt; 360)
                            {
                                EmitAngle = EmitAngle - 360;
                            }
                            else if(EmitAngle &lt; 0)
                            {
                                EmitAngle = EmitAngle + 360;
                            }
                        }
                        EmitAngleInRadians = ((EmitAngle*pi)/180);
                        EmitAngleArray[EmitTracker] = EmitAngle;
                                
                        //loop again
                        Searching = false;
                    }
                        //instance_destroy();
               }
            }
        }
        i = obj_Emitter.x;
        j = obj_Emitter.y;
        EmitAngle = obj_Emitter.image_angle;
        EmitAngleInRadians = ((EmitAngle*pi)/180);
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(Emitting)
{
    for(tracker = 0; tracker &lt; EmitTracker; tracker++)
    {
        if(position_meeting(EmitArrayX[tracker],EmitArrayY[tracker],obj_Receiver))
        {
            (instance_position(EmitArrayX[tracker],EmitArrayY[tracker],obj_Receiver)).image_index = 1;
            Winning = true;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
