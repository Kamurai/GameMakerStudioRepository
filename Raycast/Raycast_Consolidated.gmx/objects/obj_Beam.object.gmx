<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>-1</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>image_speed = 1;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Emitting = false;
alarm[0] = 1;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>EmitAngle = 90;
Source = instance_nearest(x,y,obj_Emitter);

//this will be expanded to adjust for nearest Emitter or Splitter


if(!(distance_to_object(Source) &lt;= 5))
{
    instance_destroy();
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//image_angle = (Source).EmitAngle;

EmitAngleArray[1] = (Source).EmitAngle;
EmitAngle = (Source).EmitAngle;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//EmitAngle is set at this point
EmitAngleInRadians = ((EmitAngle*pi)/180);

//determine beam path:
EmitArrayX[0] = x;
EmitArrayY[0] = y;

EmitTracker = 1;
EmitAngleTracker = 1;
EmitCount = 0;

i = x;
j = y;
    
CurrentContactObject = Source;

Emitting = false;

while(!Emitting)
{
    //determine angle/emit direction
    if(EmitAngle == 0)
    {
        AdjustX = 1;
        AdjustY = 0;
    }
    else if(EmitAngle == 90)
    {
        AdjustX = 0;
        AdjustY = -1;
    }
    else if(EmitAngle == 180)
    {
        AdjustX = -1;
        AdjustY = 0;
    }
    else if(EmitAngle == 270)
    {
        AdjustX = 0;
        AdjustY = 1;    
    }
    else if(EmitAngle == 360)
    {
        AdjustX = 1;
        AdjustY = 0;    
    }
    else if((EmitAngle &gt; 0) &amp;&amp; (EmitAngle &lt; 90)) //quadrant 1
    {
        AdjustX = cos(EmitAngleInRadians);
        AdjustY = sin(EmitAngleInRadians) * (-1);
    }
    else if((EmitAngle &gt; 90) &amp;&amp; (EmitAngle &lt; 180)) //quadrant 2
    {
        AdjustX = cos(EmitAngleInRadians);
        AdjustY = sin(EmitAngleInRadians) * (-1);
    }
    else if((EmitAngle &gt; 180) &amp;&amp; (EmitAngle &lt; 270)) //quadrant 3
    {
        AdjustX = cos(EmitAngleInRadians);
        AdjustY = sin(EmitAngleInRadians) * (-1);
    }
    else if((EmitAngle &gt; 270) &amp;&amp; (EmitAngle &lt; 360)) //quadrant 4
    {
        AdjustX = cos(EmitAngleInRadians);
        AdjustY = sin(EmitAngleInRadians) * (-1);
    }
    
             
    Searching = true;
    //loop through coordinates on line based on angle
    while(Searching)
    {
        if(Emitting)
        {
            break;
        }
        
        i= i + AdjustX;
        j= j + AdjustY;
        
        //if GameObject is found
        if(position_meeting(i,j,obj_GameObject))
        {
            //if it is the previously contacted object
            if(instance_position(i,j,obj_GameObject) == CurrentContactObject) //pivot
            {
                //the beam hasn't traveled away from the object yet
                continue;
                
                
            }
            else
            {
                CurrentContactObject = instance_position(i,j,obj_GameObject);
                
                //pivot
                    //Searching = false;
                    //Emitting = true; 
                    //break;
       
                
                //if GameObject is Opaque
                if(position_meeting(i,j,obj_Opaque))
                {
                    //then assign coordinates
                    EmitArrayX[EmitTracker] = i;
                    EmitArrayY[EmitTracker] = j;
                    EmitTracker++;
                    EmitCount++;
                    
                    //end searching
                    Searching = false;
                    Emitting = true;
                    break;
                }
                //if GameObject is Reflective
                else if(place_meeting(i,j,obj_Reflective))
                {
                    //then assign coordinates
                    EmitArrayX[EmitTracker] = i;
                    EmitArrayY[EmitTracker] = j;
                    EmitTracker++;
                    EmitCount++;
                    
                    ImageAngle = real(instance_position(i,j,obj_Reflective).image_angle);
                    
                    //handle reflection:
                    //determine from which object the light is reflecting
                    //if 2 sided mirror or 1 sided mirror
                    if(object_get_name(instance_position(i,j,obj_Reflective).object_index) == "obj_Mirror_2Sided" || object_get_name(instance_position(i,j,obj_Reflective).object_index) == "obj_Mirror_1Sided")
                    {
                        AngleDiff = (EmitAngle - ImageAngle);
                        //instance_destroy();
                    
                        while((AngleDiff &lt; 0) || (AngleDiff &gt; 359))
                        {
                        
                            if(AngleDiff &gt; 360)
                            {
                                AngleDiff = AngleDiff - 360;
                            }
                            else if(AngleDiff &lt; 0)
                            {
                                AngleDiff = AngleDiff + 360;
                            }
                        }
                        
                        //if difference is 0
                        if(AngleDiff == 0)
                        {
                            //end as if opaque (hits the side)
                            Emitting = true;
                        }
                        //if difference is 180
                        else if(AngleDiff == 180)
                        {
                            //end as if opaque (hits the side)
                            Emitting = true;
                        }
                        //if difference is 360
                        else if(AngleDiff == 360)
                        {
                            //end as if opaque (hits the side)
                            Emitting = true;
                        }
                        //if difference is 90
                        else if(AngleDiff == 90)
                        {
                            //end as if opaque (reflects back on itself)
                            Emitting = true;
                        }
                        //if difference is 270
                        else if(AngleDiff == 270)
                        {
                            //end as if opaque (reflects back on itself)
                            Emitting = true;
                        }
                        //if difference is from 1 to 89 //quadrant 1
                        else if( (AngleDiff &gt; 0) &amp;&amp; (AngleDiff &lt; 90) )
                        {
                            //if reflecting vertically (quadrant 1 to quandrant 4)
                            EmitAngle = ImageAngle - (EmitAngle - 180) + (ImageAngle - 180);
                            EmitAngleInRadians = ((EmitAngle*pi)/180);
                        }
                        //if difference is from 91 to 179 //quadrant 2
                        else if( (AngleDiff &gt; 90) &amp;&amp; (AngleDiff &lt; 180) )
                        {
                            //if reflecting vertically (quadrant 2 to quandrant 3)
                            EmitAngle = ImageAngle - (EmitAngle - 180) + (ImageAngle - 180);
                            EmitAngleInRadians = ((EmitAngle*pi)/180);
                        }
                        //if difference is from 181 to 269 //quadrant 3
                        else if( (AngleDiff &gt; 180) &amp;&amp; (AngleDiff &lt; 270) )
                        {
                            //if reflecting vertically (quadrant 3 to quandrant 2)
                            EmitAngle = ImageAngle - (EmitAngle - 180) + (ImageAngle - 180);
                            EmitAngleInRadians = ((EmitAngle*pi)/180);
                        }
                        //if difference is from 271 to 359 //quadrant 4
                        else if( (AngleDiff &gt; 270) &amp;&amp; (AngleDiff &lt; 360) )
                        {
                            //if reflecting vertically (quadrant 4 to quandrant 1)
                            EmitAngle = ImageAngle - (EmitAngle - 180) + (ImageAngle - 180);
                            EmitAngleInRadians = ((EmitAngle*pi)/180);
                            
                        }
                    }
                    
                    while((EmitAngle &lt; 0) || (EmitAngle &gt; 359))
                    {
                    
                        if(EmitAngle &gt; 360)
                        {
                            EmitAngle = EmitAngle - 360;
                        }
                        else if(EmitAngle &lt; 0)
                        {
                            EmitAngle = EmitAngle + 360;
                        }
                    }
                    EmitAngleInRadians = ((EmitAngle*pi)/180);
                    EmitAngleArray[EmitTracker] = EmitAngle;
                    
                    //loop again
                    Searching = false;
                }
           }
       } 
       
       
                    
    }
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
if(position_meeting(EmitArrayX[EmitTracker-1],EmitArrayY[EmitTracker-1],obj_Receiver))
{
    if((instance_position(EmitArrayX[EmitTracker-1],EmitArrayY[EmitTracker-1],obj_Receiver)).Connected == 0)
    {
        (instance_position(EmitArrayX[EmitTracker-1],EmitArrayY[EmitTracker-1],obj_Receiver)).image_index = 1;
        (instance_position(EmitArrayX[EmitTracker-1],EmitArrayY[EmitTracker-1],obj_Receiver)).Connected = 1;
        obj_Play_Controller.Winning = 0;
        
        with(obj_Receiver)
        {
            if(Connected == 1)
            {
                obj_Play_Controller.Winning = obj_Play_Controller.Winning + 1;
            }
        }
    }    
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(Emitting)
{
    //draw beam path based on returned array:
    //walk through emit array based on emit count
    LineTracker = 0;
    for(tracker = 0; tracker &lt; (EmitCount); tracker++)
    {
        draw_set_color(c_white);
        //draw_line(EmitArrayX[tracker], EmitArrayY[tracker],EmitArrayX[tracker+1],EmitArrayY[tracker+1]);
        EmitScaleX = (abs(EmitArrayX[tracker] - EmitArrayX[tracker+1])/sprite_width);
        //EmitScaleY = (abs(EmitArrayY[tracker] - EmitArrayY[tracker+1])/sprite_height);
        
        EmitScaleY = point_distance(EmitArrayX[tracker], EmitArrayY[tracker], EmitArrayX[tracker+1], EmitArrayY[tracker+1])/sprite_height;
        
        
        if(EmitScaleX == 0)
        {
            EmitScaleX = 1;
        }
        
        if(EmitScaleY == 0)
        {
            EmitScaleY = 1;
        }
        
        
        draw_sprite_ext(sprite_index,image_index,EmitArrayX[tracker+1],EmitArrayY[tracker+1],sprite_width,EmitScaleY,EmitAngleArray[tracker+1]-90,c_white,image_alpha);
         
        if((tracker == 0) || (tracker mod 2) == 0 )
        {
            LineTracker = LineTracker + 2;
        }
        
    }    
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
